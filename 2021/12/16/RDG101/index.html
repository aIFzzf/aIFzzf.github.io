<!DOCTYPE html>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon_study_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon_study_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Render Graph是近几年的一种组织渲染管线的架构，Unreal 和 Unity 的 SRP都实现了Render Graph。这是一种针对渲染管线的调度任务，使渲染管线的代码更容易扩展和维护，提供可视化的调试工具，收集整帧的渲染任务。本文为UE官方RDG101 ppt翻译版本，如有错误，欢迎指正。">
<meta property="og:type" content="article">
<meta property="og:title" content="RDG101">
<meta property="og:url" content="http://example.com/2021/12/16/RDG101/index.html">
<meta property="og:site_name" content="风中追风">
<meta property="og:description" content="Render Graph是近几年的一种组织渲染管线的架构，Unreal 和 Unity 的 SRP都实现了Render Graph。这是一种针对渲染管线的调度任务，使渲染管线的代码更容易扩展和维护，提供可视化的调试工具，收集整帧的渲染任务。本文为UE官方RDG101 ppt翻译版本，如有错误，欢迎指正。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/UE4.26_RenderGraph%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled2.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled3.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled4.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled5.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled6.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled7.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled8.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled9.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled10.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled11.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled12.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled13.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled15.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled16.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled18.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled19.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled20.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled21.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled22.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled23.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled24.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled25.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled26.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled27.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled28.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled29.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled30.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled31.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled32.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled33.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled34.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled35.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled36.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled37.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled38.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled39.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled40.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled41.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled42.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled43.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled44.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled45.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled46.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled47.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled48.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled49.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled50.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled51.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled52.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled53.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled54.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled55.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled56.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled57.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled58.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled59.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled60.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled61.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled62.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled63.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled65.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled66.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled67.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled68.png">
<meta property="og:image" content="http://example.com/2021/12/16/RDG101/Untitled69.png">
<meta property="article:published_time" content="2021-12-16T14:56:20.000Z">
<meta property="article:modified_time" content="2023-04-25T15:10:13.987Z">
<meta property="article:author" content="NeoZheng">
<meta property="article:tag" content="性能">
<meta property="article:tag" content="渲染">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/12/16/RDG101/UE4.26_RenderGraph%E6%B5%81%E7%A8%8B.png">

<link rel="canonical" href="http://example.com/2021/12/16/RDG101/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RDG101 | 风中追风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="风中追风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">风中追风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/16/RDG101/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/MyShow.jpg">
      <meta itemprop="name" content="NeoZheng">
      <meta itemprop="description" content="潜心技术，努力奋斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风中追风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RDG101
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-16 22:56:20" itemprop="dateCreated datePublished" datetime="2021-12-16T22:56:20+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-25 23:10:13" itemprop="dateModified" datetime="2023-04-25T23:10:13+08:00">2023-04-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UnrealEngine/" itemprop="url" rel="index"><span itemprop="name">UnrealEngine</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/12/16/RDG101/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/12/16/RDG101/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>
            <div class="post-description">Render Graph是近几年的一种组织渲染管线的架构，Unreal 和 Unity 的 SRP都实现了Render Graph。这是一种针对渲染管线的调度任务，使渲染管线的代码更容易扩展和维护，提供可视化的调试工具，收集整帧的渲染任务。本文为UE官方RDG101 ppt翻译版本，如有错误，欢迎指正。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<p>首先上UE 4.26 RenderGraph的流程图</p>
<p><img src="UE4.26_RenderGraph%E6%B5%81%E7%A8%8B.png"></p>
<p>以及RDG的相关定义及本ppt相关主题：</p>
<p><img src="Untitled2.png"></p>
<p><img src="Untitled3.png"></p>
<h1 id="Shader-Parameters"><a href="#Shader-Parameters" class="headerlink" title="Shader Parameters"></a>Shader Parameters</h1><p>为了了解RDG结构，有必要了解shader parameter如何在UE引擎中展示</p>
<p>首先先看下在Shader中input，这些shader input 与一个用户可自定义的C++结构体相关联，并作为一个collection提交。不幸的是，虽然易于创作，但着色器编译器运行时无法验证这种表示</p>
<p>(下图右侧为理想C++情况)</p>
<p><img src="Untitled4.png"></p>
<h2 id="Shader-Parameter-Structs"><a href="#Shader-Parameter-Structs" class="headerlink" title="Shader Parameter Structs"></a><strong>Shader Parameter Structs</strong></h2><p>UE时使用一个宏系统定义shader属性结构，会在编译时自动生成反射。</p>
<p><img src="Untitled5.png"></p>
<h2 id="Compile-Time-Reflection-Metadata"><a href="#Compile-Time-Reflection-Metadata" class="headerlink" title="Compile-Time Reflection Metadata"></a><strong>Compile-Time Reflection Metadata</strong></h2><p><img src="Untitled6.png"></p>
<blockquote>
<p>在C++中，用户可以遍历访问来自每个成员的信息：<br>Name, Type, Shader Type, Byte offset from start of struct<br>这对于从 RDG / RHI 中的 void* 结构指针中提取资源是必要的。</p>
</blockquote>
<p>Engine\Source\Runtime\RenderCore\Private\ShaderParameterMetadata.cpp</p>
<p>shader 属性宏系统的特点是会自动生成 compile-time 的 reflection metadat。任何用户都可以在runtime时遍历shader 属性结构并获取每个单位的信息。要从公共代码（例如 RHI / RDG）中结构的 void* 指针表示中遍历和提取资源，元数据是必需的。</p>
<h2 id="0-04-Automatic-Parameter-Alignment自动属性对齐"><a href="#0-04-Automatic-Parameter-Alignment自动属性对齐" class="headerlink" title="0.04 Automatic Parameter Alignment自动属性对齐"></a>0.04 <strong>Automatic Parameter Alignment</strong>自动属性对齐</h2><p><img src="Untitled7.png"></p>
<p>详细define 请见：Engine\Source\Runtime\RenderCore\Public\ShaderParameterMacros.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Begins &amp; ends a shader parameter structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *	BEGIN_SHADER_PARAMETER_STRUCT(FMyParameterStruct, RENDERER_API)</span></span><br><span class="line"><span class="comment"> *	END_SHADER_PARAMETER_STRUCT()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_SHADER_PARAMETER_STRUCT(StructTypeName, PrefixKeywords) \</span></span><br><span class="line"><span class="meta">	INTERNAL_SHADER_PARAMETER_STRUCT_BEGIN(StructTypeName, PrefixKeywords, &#123;&#125;, INTERNAL_SHADER_PARAMETER_GET_STRUCT_METADATA(StructTypeName), INTERNAL_SHADER_PARAMETER_STRUCT_CREATE_UNIFORM_BUFFER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_SHADER_PARAMETER_STRUCT()</span></span><br></pre></td></tr></table></figure>

<p>另一个宏系统的特点就是能自动对齐shader 数据。虚幻引擎使用与平台无关的数据对齐规则来实现着色器的可移植性。</p>
<p>主要规则是每个成员都与其大小的下一个 2 次幂对齐——但前提是大于四个字节。例如：</p>
<ul>
<li>指针是八字节对齐的（即使在 32 位平台上）；</li>
<li>Float、uint32、int32为四字节对齐；</li>
<li>FVector2D, FIntPoint 为八字节对齐；</li>
<li>FVector 和 FVector4 是 16 个字节对齐的。</li>
</ul>
<p>每个成员的自动对齐将不可避免地创建填充，如上面的评论所示。</p>
<h3 id="0-05-Sort-Members-to-Minimize-Padding对成员进行排序以最小化填充"><a href="#0-05-Sort-Members-to-Minimize-Padding对成员进行排序以最小化填充" class="headerlink" title="0.05.Sort Members to Minimize Padding对成员进行排序以最小化填充"></a>0.05.<strong>Sort Members to Minimize Padding对成员进行排序以最小化填充</strong></h3><p><img src="Untitled8.png"></p>
<p>顺便说一句，请考虑组织结构以最小化或消除填充。参数的顺序不会以任何方式影响着色器源，因此这是一个低风险的更改，将导致上传到 GPU 的字节更少。</p>
<p>在上面的示例中，向上移动“float World”使其位于 FVector2D ViewportSize（三浮点结构）所需的四字节填充区域中。同样，这个三浮点向量将与十六个字节（或四个浮点数）对齐，因此将单浮点成员移动到第四个浮点槽将消除填充。</p>
<h3 id="0-06-Example-of-Tightly-Packed-Structure"><a href="#0-06-Example-of-Tightly-Packed-Structure" class="headerlink" title="0.06:Example of Tightly Packed Structure"></a>0.06:Example of Tightly Packed Structure</h3><p><img src="Untitled9.png"></p>
<p>上面截取的代码演示了一个紧密存储的着色器参数结构。每个 FVector {x, y, z} 后跟一个浮点数以完成十六字节的内存槽。</p>
<h3 id="0-07-No-Need-to-Manually-Pack-Floats无需手动打包浮点数"><a href="#0-07-No-Need-to-Manually-Pack-Floats无需手动打包浮点数" class="headerlink" title="0.07:No Need to Manually Pack Floats无需手动打包浮点数"></a>0.07:No Need to Manually Pack Floats无需手动打包浮点数</h3><p><img src="Untitled10.png"></p>
<p>shader作者需要手动将松散的浮点数打包成一个更大的 4 宽向量。</p>
<p>只要遵循填充规则，在使用 SHADER_PARAMETER_STRUCT 系统时这不是必需的。</p>
<p>通过避免通用参数向量（例如 MyFeatureParams.{x, y, z, w}），保持这些数据松散可以提高可读性。对于着色器源文件也是如此，它可以简单地声明带有友好名称的松散参数。</p>
<p>一个例外是参数数组。系统不会显式地将参数合并到单个数组中；你仍然必须自己做。</p>
<h3 id="0-08-First-Shader-Class"><a href="#0-08-First-Shader-Class" class="headerlink" title="0.08.First Shader Class"></a><strong>0.08.First Shader Class</strong></h3><p><img src="Untitled11.png"></p>
<p>现在我们的着色器有了一个着色器参数结构，我们需要定义着色器本身。在现有的着色器框架中使用新的着色器参数系统是easy的。</p>
<p>首先，将 SHADER_USE_PARAMETER_STRUCT() 宏添加到shader class。这实现了类的构造函数并配置着色器以使用声明的着色器参数结构。</p>
<p>光追着色器需要改用 SHADER_USE_ROOT_PARAMETER_STRUCT()，因为 RHI 处理它们的方式存在一些细微差别。此要求是暂时的(4.26)，将在着色器系统的未来修订版中删除。</p>
<p>配置后，着色器将在类中查找 FParameters 成员。这应该分配给您打算使用的着色器参数结构的类型。自然地，每个着色器只允许一个着色器参数结构。</p>
<p>这两个步骤是您开始使用着色器参数结构系统所需的全部步骤。该类将自动反映和绑定着色器参数。请注意，着色器编译器还将验证针对此结构的绑定。例如，C++ 中的类型现在将生成有用的错误消息，而不是静默失败。</p>
<h3 id="0-09-Inlining-the-Struct-Definition内联结构定义"><a href="#0-09-Inlining-the-Struct-Definition内联结构定义" class="headerlink" title="0.09:Inlining the Struct Definition内联结构定义"></a><strong>0.09:Inlining the Struct Definition内联结构定义</strong></h3><p><img src="Untitled12.png"></p>
<p>/Engine/Source/Runtime/Renderer/Private/各类文件夹内</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FVirtualVoxelGenerateMipCS</span> : <span class="keyword">public</span> FGlobalShader</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">DECLARE_GLOBAL_SHADER</span>(FVirtualVoxelGenerateMipCS);</span><br><span class="line">	<span class="built_in">SHADER_USE_PARAMETER_STRUCT</span>(FVirtualVoxelGenerateMipCS, FGlobalShader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters, )</span><br><span class="line">		<span class="built_in">SHADER_PARAMETER_STRUCT_INCLUDE</span>(FSceneTextureParameters, SceneTextures)</span><br><span class="line">		<span class="built_in">SHADER_PARAMETER</span>(FIntVector, PageCountResolution)</span><br><span class="line">		<span class="built_in">SHADER_PARAMETER</span>(uint32, PageResolution)</span><br><span class="line">		<span class="built_in">SHADER_PARAMETER</span>(uint32, SourceMip)</span><br><span class="line">		<span class="built_in">SHADER_PARAMETER</span>(uint32, TargetMip)</span><br><span class="line"></span><br><span class="line">		<span class="built_in">SHADER_PARAMETER_RDG_BUFFER</span>(StructuredBuffer, IndirectDispatchArgs)</span><br><span class="line">		<span class="built_in">SHADER_PARAMETER_RDG_TEXTURE_SRV</span>(Texture3D, InDensityTexture)</span><br><span class="line">		<span class="built_in">SHADER_PARAMETER_RDG_TEXTURE_UAV</span>(RWTexture3D, OutDensityTexture)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">END_SHADER_PARAMETER_STRUCT</span>()</span><br><span class="line">(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与参数结构具有一对一关系的着色器的最佳实践是直接在类上声明参数（作为 FParameters）。这是最简单、最清晰的方法。</p>
<h3 id="0-10-Assigning-Parameters声明属性"><a href="#0-10-Assigning-Parameters声明属性" class="headerlink" title="0.10:Assigning Parameters声明属性"></a><strong>0.10:Assigning Parameters声明属性</strong></h3><p><img src="Untitled13.png"></p>
<p>我们的着色器现在配置了一个着色器参数结构。我们现在需要为这些参数赋值并将它们推送到 RHI。首先，FParameters 类型只是一个结构体；您可以实例化并填充它。这使得调试变得微不足道，因为您现在可以在调试器中查看结构体的全部内容。</p>
<p>新设计的一个关键区别在于着色器参数设置与着色器类分离。这通过将参数设置移动到更高级别的pass代码中来提高清晰度，而不是将其与样板嵌入到着色器类中。这会产生更自然的数据流，更易于阅读和调试。</p>
<h3 id="0-11：Submitting-Parameters提交属性"><a href="#0-11：Submitting-Parameters提交属性" class="headerlink" title="0.11：Submitting Parameters提交属性"></a>0.11：Submitting Parameters提交属性</h3><p>![](Untitled 14.png)</p>
<p>/Engine/Source/RenderCore/Public/ShaderParameterStruct.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Set shader&#x27;s parameters from its parameters struct. */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TRHICmdList, <span class="keyword">typename</span> TShaderClass, <span class="keyword">typename</span> TShaderRHI&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SetShaderParameters</span><span class="params">(TRHICmdList&amp; RHICmdList, <span class="type">const</span> TShaderRef&lt;TShaderClass&gt;&amp; Shader, TShaderRHI* ShadeRHI, <span class="type">const</span> <span class="keyword">typename</span> TShaderClass::FParameters&amp; Parameters)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>着色器参数系统提供了一个辅助函数 SetShaderParameters，将参数推送到 RHI 命令列表。这提供了在调试器中检查着色器参数值的清晰位置。</p>
<p>此函数将根据正在使用的特定着色器排列验证结构的内容。如果所需资源为空，则会发出错误。作为旁注，结构的所有成员都默认初始化为 null、零或默认构造函数（取决于类型）。</p>
<p>这也意味着如果排列不使用资源，则可以安全地忽略它。</p>
<h3 id="0-12：Defining-a-Uniform-Buffer"><a href="#0-12：Defining-a-Uniform-Buffer" class="headerlink" title="0.12：Defining a Uniform Buffer"></a>0.12：Defining a Uniform Buffer</h3><p><img src="Untitled15.png"></p>
<p>统一缓冲区使用相同的着色器参数结构模型，但有自己的专用宏来将参数声明为“全局”。</p>
<h3 id="0-13-Uniform-Buffer-Code-Generation"><a href="#0-13-Uniform-Buffer-Code-Generation" class="headerlink" title="0.13:Uniform Buffer Code Generation"></a><strong>0.13:Uniform Buffer Code Generation</strong></h3><p><img src="Untitled16.png"></p>
<blockquote>
<p>Common.ush 已经include生成的shader代码<br>然后就可以作为一个全局结构（存储在unifrom buffer）去访问<br>从长远来看，着色器参数和统一缓冲区之间的 HLSL 不应有语法差异。</p>
</blockquote>
<p>全局着色器参数结构具有自动反映在着色器代码中的附加功能（和开销），以及一些 HLSL 语法特殊性的处理。</p>
<h3 id="0-14-Include-Uniform-Buffers-in-Shader-Parameter-Structs"><a href="#0-14-Include-Uniform-Buffers-in-Shader-Parameter-Structs" class="headerlink" title="0.14 Include Uniform Buffers in Shader Parameter Structs"></a>0.14 Include Uniform Buffers in Shader Parameter Structs</h3><p><img src="Untitled18.png"></p>
<p>shader属性结构可通过SHADER_PARAMETER_STRUCT_REF()变体依赖于uniform buffers。</p>
<p>由于此着色器绑定名称由 IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT() 定义，因此引用的统一缓冲区的成员名称仅由 C++ 使用。</p>
<p>最后，因为只有一个全局定义的绑定名称，所以一次只能绑定一个统一缓冲区的实例。</p>
<h1 id="Render-Graph-Basics"><a href="#Render-Graph-Basics" class="headerlink" title="Render Graph Basics"></a>Render Graph Basics</h1><h2 id="1-00-The-Render-Graph-Builder"><a href="#1-00-The-Render-Graph-Builder" class="headerlink" title="1.00 The Render Graph Builder"></a><strong>1.00 The Render Graph Builder</strong></h2><p><img src="Untitled19.png"></p>
<p>render graph API从构建器开始，这个构建器接口通过资源和passes的立即模式声明来促进graph的设置。该graph是通过设置阶段逐步构建。一旦所有setup完成后，graph将执行，它会以依赖项排序的顺序编译并调用所有的pass。除其他外，这种设计可实现 GPU 工作的高效调度和更积极的内存管理。</p>
<p>API 易于使用。您只需定义一个graph builder 实例，执行设置操作并执行。构建器是单线程的（总是在渲染线程上！）并且在执行之间不保留任何状态。整个图被重建每一帧。</p>
<p>为了真正实现全帧优化，最终目标是将整个引擎移植到使用相同的图形构建器实例。这将需要一段时间。 “移植”现有代码或编写新渲染代码的首选模式是定义您自己的本地图形构建器实例并手动执行它。随着引擎的各个部分被移植，它们都将合并到同一个构建器实例中。</p>
<h2 id="1-01-Creating-a-Texture"><a href="#1-01-Creating-a-Texture" class="headerlink" title="1.01 Creating a Texture"></a>1.01 Creating a Texture</h2><p><img src="Untitled20.png"></p>
<p>创建新Texture，你只需要在graph builder中调用 <em>CreateTexture</em> 。它会在graph builder 实例的生命周期中返回一个可用的RDG texture 句柄。单独的类型是必要的，因为物理 GPU 资源不会立即分配。RDG 指针表示未来资源的句柄，保证对每次使用它的pass都是有效的。</p>
<p>资源如何与pass相关联的详细信息将在稍后介绍。我们在上面的代码中所做的就是在图形上声明纹理。</p>
<h2 id="1-02-Creating-a-UAV-for-a-Texture"><a href="#1-02-Creating-a-UAV-for-a-Texture" class="headerlink" title="1.02 Creating a UAV for a Texture"></a><strong>1.02 Creating a UAV for a Texture</strong></h2><p><img src="Untitled21.png"></p>
<p> 同样，您可以使用构建器来创建资源（纹理或缓冲区）的视图。上面的代码示例在指定的 mip 级别创建了纹理的 UAV。</p>
<h2 id="1-03-Creating-an-SRV-for-a-Texture"><a href="#1-03-Creating-an-SRV-for-a-Texture" class="headerlink" title="1.03 Creating an SRV for a Texture"></a><strong>1.03 Creating an SRV for a Texture</strong></h2><p><img src="Untitled22.png"></p>
<p>SRV 也受支持并遵循相同的一般创建模式</p>
<h2 id="1-04-Pass-Parameters"><a href="#1-04-Pass-Parameters" class="headerlink" title="1.04 Pass Parameters"></a><strong>1.04 Pass Parameters</strong></h2><p><img src="Untitled23.png"></p>
<p>为了连接RDG资源和pass，我们使用一个修改过的SHADER_PARAMETER_STRUCT 来声明 RDG shader parameters。这个shader 属性的变体接受C++ RDG resource 指针。graph会转换在pass中的struct 并注册 RDG 资源给相关的pass使用。这就是内存管理优势发挥作用的地方，因为graph能够仅根据Pass如何使用资源来推断资源的生命周期。</p>
<p>请看上面代码，有人可能会问为什么我们使用一个shader parameter struct代表pass parameter而不是其他pass parameter struct。这是一个有意识的设计决定，以简化使用着色器（这是引擎中最常见的pass类型）的 1 对 1 pass的创作。上面的着色器参数结构有两个目的：</p>
<ol>
<li>Pass 设置：由于几乎所有的资源都是由shader产生、消耗的。我们可以从shader 的metadata中获取到资源将如何在pass中被使用（Read、Write）。这个信息对于资源转化很重要。</li>
<li>设置属性值给Command List：pass内的shader不需要‘提取’pass资源；它可以简单地绑定整个结构。 RHI 着色器参数绑定代码会自动取消引用 RDG 资源。</li>
</ol>
<p>通过将Pass/资源关联组合到着色器参数结构中，编写单着色器Pass变得微不足道。大量减少样板文件，提高了整个代码库的可维护性。</p>
<p>总结一下：着色器参数结构提供了使用 RDG 资源的扩展。这个着色器参数结构提供了一个 RDG Pass，它遍历并提取设置Pass资源所需的所有信息。</p>
<h2 id="1-05-Adding-a-Pass"><a href="#1-05-Adding-a-Pass" class="headerlink" title="1.05 Adding a Pass"></a><strong>1.05 Adding a Pass</strong></h2><p><img src="Untitled24.png"></p>
<p>为了向图形添加pass，构建器提供了 AddPass 函数。此函数接受在图形执行期间调用的 lambda。 lambda 提供了一个 RHI 命令列表来将工作分派给 RHI。pass接受一个着色器参数结构，并将反映它的所有 <em>RDG</em> 参数。所有其他着色器参数都将被忽略。</p>
<h2 id="1-06-Profile-Events"><a href="#1-06-Profile-Events" class="headerlink" title="1.06 Profile Events"></a><strong>1.06 Profile Events</strong></h2><p><img src="Untitled25.png"></p>
<p>每个RDG pass接受一个格式化的名称，该名称暴露给ProfileGPU命令和外部GPU profiler。我们鼓励您填写足够的信息以唯一标识通行证。请注意，出于性能原因，此信息已从发布版本中删除。</p>
<h2 id="1-07-Pass-Parameter-Setup"><a href="#1-07-Pass-Parameter-Setup" class="headerlink" title="1.07 Pass Parameter Setup"></a><strong>1.07 Pass Parameter Setup</strong></h2><p><img src="Untitled26.png"></p>
<p>如前所述，graph需要知道pass将访问哪个 RDG 资源，它从pass参数结构中收集。但是，由于graph执行被推迟，因此需要分配此结构以匹配graph的生命周期。graph构建器界面提供了一个 AllocParameters 函数，该函数针对graph的生命周期进行了优化。我们更喜欢为此对象使用 PassParameters 命名约定。</p>
<p>关于pass参数结构和passes的一些规则：</p>
<ul>
<li>pass参数实例一旦通过 AddPass 关联到pass，就被认为是不可变的。pass承担指针的所有权（包括销毁）。只有一次pass,我使用pass参数实例（它们必须是 1 对 1）。要支持多次pass，您必须为每个pass实例化一个唯一的实例。</li>
<li>分配pass参数实例然后不将其关联到pass是无效的。</li>
<li>您只能访问pass lambda 中 RDG 类型的底层 RHI 资源，并且仅当 RDG 类型在与pass关联的pass参数实例上声明时。</li>
</ul>
<p>如果违反这些条件，RDG 验证层将发出错误。</p>
<h2 id="1-08-Pass-Execution-Lambda-Function"><a href="#1-08-Pass-Execution-Lambda-Function" class="headerlink" title="1.08 Pass Execution Lambda Function"></a>1.08 Pass Execution Lambda Function</h2><p><img src="Untitled27.png"></p>
<h2 id="1-09-Render-Target-Bindings-Slots"><a href="#1-09-Render-Target-Bindings-Slots" class="headerlink" title="1.09 Render Target Bindings Slots"></a><strong>1.09 Render Target Bindings Slots</strong></h2><p><img src="Untitled28.png"></p>
<p>在创作使用光栅管道的pass时，将 RENDER_TARGET_BINDING_SLOTS() 宏添加到pass参数结构中。这将公开渲染目标和深度模板的输入，这些输入将由Pass拾取。着色器会忽略此数据。</p>
<h2 id="1-10-Binding-a-Color-Render-Target"><a href="#1-10-Binding-a-Color-Render-Target" class="headerlink" title="1.10 Binding a Color Render Target"></a><strong>1.10 Binding a Color Render Target</strong></h2><p><img src="Untitled29.png"></p>
<p>渲染目标作为绑定数组公开。每个绑定都接受一个 RDG 纹理以及加载/存储操作。</p>
<h2 id="1-11-Binding-Depth-Stencil-Target"><a href="#1-11-Binding-Depth-Stencil-Target" class="headerlink" title="1.11 Binding Depth Stencil Target"></a><strong>1.11 Binding Depth Stencil Target</strong></h2><p><img src="Untitled30.png"></p>
<p>同样，深度模板作为单独的绑定公开。它还接受 RDG 纹理以及分别加载/存储深度和模板的动作。此外，您可以指定纹理是读取还是读写。</p>
<h2 id="1-12-Binding-UAVs-for-Pixel-Shaders"><a href="#1-12-Binding-UAVs-for-Pixel-Shaders" class="headerlink" title="1.12 Binding UAVs for Pixel Shaders"></a><strong>1.12 Binding UAVs for Pixel Shaders</strong></h2><p><img src="Untitled31.png"></p>
<p>也可以为像素着色器绑定UAV。</p>
<h2 id="1-13-Registration"><a href="#1-13-Registration" class="headerlink" title="1.13 Registration"></a><strong>1.13 Registration</strong></h2><p><img src="Untitled32.png"></p>
<blockquote>
<p>如果需要注册与 RHI 资源不同的资源（例如非常旧的 FRenderTarget），请检查 GRenderTargetPool.CreateUntrackedElement() 以获取 TRefCountPtr<IPooledRenderTarget></p>
</blockquote>
<p>渲染 graph 目前使用 IPooledRenderTarget 接口来控制纹理的分配。有时需要将现有资源导入图中（尤其是在 RDG 转换过程中）。构建器公开 RegisterExternalTexture，它返回由现有渲染目标支持的 RDG 纹理实例。</p>
<h2 id="1-14-Extraction-Queries"><a href="#1-14-Extraction-Queries" class="headerlink" title="1.14 Extraction Queries"></a><strong>1.14 Extraction Queries</strong></h2><p><img src="Untitled33.png"></p>
<p>池化渲染目标指针也可以从 FRDGTexture 中提取。这允许您跨图形调用保留资源的内容。</p>
<p>但是，提取会推迟到图执行完毕；这是因为在执行期间可能会根据graph中资源的生命周期分配资源。</p>
<p>因此，API 公开了 QueueTextureExtraction，它允许您提供一个指针，该指针将在执行graph时填充。</p>
<h2 id="1-15-Creating-Buffers"><a href="#1-15-Creating-Buffers" class="headerlink" title="1.15 Creating Buffers"></a><strong>1.15 Creating Buffers</strong></h2><p><img src="Untitled34.png"></p>
<p>API 自然地公开了为它们创建缓冲区和视图的方法。</p>
<h2 id="1-16-Reading-from-a-Buffer-Using-an-SRV"><a href="#1-16-Reading-from-a-Buffer-Using-an-SRV" class="headerlink" title="1.16 Reading from a Buffer Using an SRV"></a><strong>1.16 Reading from a Buffer Using an SRV</strong></h2><p><img src="Untitled35.png"></p>
<p>缓冲区只能使用 SHADER_PARAMETER_RDG_BUFFER_SRV() 通过 SRV 从着色器读取。</p>
<h2 id="1-17-Indirect-Draw-Dispatch-Buffer"><a href="#1-17-Indirect-Draw-Dispatch-Buffer" class="headerlink" title="1.17 Indirect Draw/Dispatch Buffer"></a><strong>1.17 Indirect Draw/Dispatch Buffer</strong></h2><p><img src="Untitled36.png"></p>
<p>间接绘制/分派缓冲区有点独特，因为它们不被着色器直接使用。相反，在pass参数上将它们声明为 RDG 缓冲区，然后直接在pass中使用 RHI 间接绘制缓冲区。</p>
<h1 id="Pass-Debugging-and-Methodology"><a href="#Pass-Debugging-and-Methodology" class="headerlink" title="Pass Debugging and Methodology"></a>Pass Debugging and Methodology</h1><h2 id="2-00-VisualizeTexture-Integration"><a href="#2-00-VisualizeTexture-Integration" class="headerlink" title="2.00 VisualizeTexture Integration"></a><strong>2.00 VisualizeTexture Integration</strong></h2><p><img src="Untitled37.png"></p>
<blockquote>
<p>List 所有可用texture<br>vis<br>查看名为“DOFGatherForeground”的texture<br>vis DOFGatherForeground</p>
</blockquote>
<p>RDG 自动将 FRDGTexture 暴露给可视化纹理工具。任何写操作都会被记录下来。只需在控制台中直接输入您为 CreateTexture() 提供的调试名称，它就会出现。</p>
<p>如果您有多个Pass修改或重新定义具有相同调试名称的新纹理，则捕获Pass将捕获所有这些Pass，但仅显示最后一个捕获实例。</p>
<h2 id="2-01-Selecting-a-Resource-Version"><a href="#2-01-Selecting-a-Resource-Version" class="headerlink" title="2.01 Selecting a Resource Version"></a><strong>2.01 Selecting a Resource Version</strong></h2><p><img src="Untitled38.png"></p>
<blockquote>
<p>具体看第二次迭代“DOFGatherForeground”<br>vis DOFGatherForeground@1</p>
</blockquote>
<p>可以使用 @N 语法选择要可视化的资源版本</p>
<h2 id="2-02-The-Downside-of-Deferred-Execution"><a href="#2-02-The-Downside-of-Deferred-Execution" class="headerlink" title="2.02 The Downside of Deferred Execution"></a><strong>2.02 The Downside of Deferred Execution</strong></h2><p><img src="Untitled39.png"></p>
<blockquote>
<p>在DOF‘s IndirectScatter pass中的断点例子<br>DOF 的 IndirectScatter pass 的 lambda 中的调用堆栈<br>RDG实现的Callstack<br>后处理链中的调用堆栈，而不是 DOF。 :(<br>pass的设置可能包含您的错误的原因，但在执行pass时它早已消失…..</p>
</blockquote>
<p>延迟执行的一个主要缺点是它使调试变得困难。如果在pass执行期间出现问题，则问题的根源可能在设置阶段。但是，由于设置堆栈帧早已消失，您将丢失所有中间设置信息。虽然可以在设置代码中设置断点，但问题可能是虚假发生的，或者pass可能是常见的执行路径（例如采样操作）。</p>
<h2 id="2-03-rdgimmediate"><a href="#2-03-rdgimmediate" class="headerlink" title="2.03 -rdgimmediate"></a><strong>2.03 -rdgimmediate</strong></h2><p><img src="Untitled40.png"></p>
<blockquote>
<p>添加后立即执行pass<br>产生与延迟执行相同的功能行为；<br>如果执行中断，则易于检查设置代码；<br>在 AddPass() 之后不能修改 PassParameter 的原因<br>可在运行时使用 r.RDG.ImmediateMode 切换<br>占用大量内存；考虑以较低的分辨率运行：r.Test.SecondaryUpscaleOverride</p>
</blockquote>
<p>为了解决这个问题，RDG 能够在立即模式下运行。这将在 AddPass 期间立即执行pass。这种模式使用大量内存，因为在整个设置过程中必须在所有分配上保持引用（我们不知道是否会使用资源！）。但是，调试的好处是巨大的：您可以在执行期间设置断点，并可以清楚地看到出错的调用堆栈。可以在启动时或运行时启用此模式。</p>
<h2 id="2-04-rdgimmediate-in-action"><a href="#2-04-rdgimmediate-in-action" class="headerlink" title="2.04 -rdgimmediate in action"></a>2.04 -rdgimmediate in action</h2><p><img src="Untitled41.png"></p>
<p>在这个例子中，我们在景深 IndirectScatter pass中遇到了一个断点。启用立即模式后，我们可以浏览在设置阶段准备的 ConvolutionTextures 数据结构的内容，以调查问题。</p>
<h2 id="2-05-Early-Validation-of-Shader-Parameters着色器参数的早期验证"><a href="#2-05-Early-Validation-of-Shader-Parameters着色器参数的早期验证" class="headerlink" title="2.05 Early Validation of Shader Parameters着色器参数的早期验证"></a>2.05 Early Validation of Shader Parameters着色器参数的早期验证</h2><p><img src="Untitled42.png"></p>
<p>一个常见的错误是将所需的着色器参数留空。如前所述，SetShaderParameters 函数将验证是否存在所有必需的着色器参数。但是，最好在设置时发现这些问题。因此，提供 ValidateShaderParameters 以允许您确保在添加到Pass之前所有内容都存在。</p>
<h2 id="2-06-rdgdebug"><a href="#2-06-rdgdebug" class="headerlink" title="2.06 -rdgdebug"></a>2.06 -rdgdebug</h2><p><img src="Untitled43.png"></p>
<blockquote>
<p>额外的验证警告，因为 CPU 成本太高而无法一直检查<br>捕捉诸如（但不限于）之类的东西：<br>pass不需要的资源<br>通过pass产生但不需要的资源<br>可在运行时使用 r.RDG.Debug=1 进行切换。</p>
</blockquote>
<p>RDG 提供了丰富的验证层，可以捕获图形设置问题以及性能问题。更昂贵的验证隐藏在 CVar 后面，它可以通过命令行或在运行时启用。验证的常见情况之一是捕获已声明但未实际使用的资源。</p>
<h2 id="2-07-Dependency-Methodology-White-Listing依赖方法：白名单"><a href="#2-07-Dependency-Methodology-White-Listing依赖方法：白名单" class="headerlink" title="2.07 Dependency Methodology:White-Listing依赖方法：白名单"></a>2.07 Dependency Methodology:White-Listing依赖方法：白名单</h2><p><img src="Untitled44.png"></p>
<p>AddPass 会访问所有在pass 属性 struct中的所有RDG资源，甚至是那些没有实际被graph execution function使用的属性。这包括分配内存和执行屏障/布局转换等操作，这些操作可能代价高昂。为了消除不必要的成本，重要的是只提供通行证实际使用的资源。由于着色器参数默认初始化为空，因此最简单的解决方案是通过根据使用条件（上例）进行分支分配来将所需资源列入白名单。</p>
<h2 id="2-08-Dependency-Methodology-Black-Listing依赖方法：黑名单"><a href="#2-08-Dependency-Methodology-Black-Listing依赖方法：黑名单" class="headerlink" title="2.08 Dependency Methodology : Black-Listing依赖方法：黑名单"></a>2.08 Dependency Methodology : Black-Listing依赖方法：黑名单</h2><p><img src="Untitled45.png"></p>
<p>同样，您也可以使用相同的逻辑来清除满足特定条件时未使用的资源。</p>
<h2 id="2-09-Automatic-Black-Listing-For-a-Single-Shader-Pass"><a href="#2-09-Automatic-Black-Listing-For-a-Single-Shader-Pass" class="headerlink" title="2.09 Automatic Black-Listing For a Single-Shader Pass"></a>2.09 Automatic Black-Listing For a Single-Shader Pass</h2><p><img src="Untitled46.png"></p>
<blockquote>
<p>在修改你的pass属性前自动执行 ValidateShaderParameters()</p>
</blockquote>
<p>大多数情况下，pass 只是包装单个计算或像素着色器操作。由于着色器包含许多排列，这会造成潜在的维护噩梦，必须手动调整pass参数以将未使用的资源列入黑名单。</p>
<p>相反，RDG 提供了一个实用函数，可以为您执行此操作：ClearUnusedGraphResources。该函数采用单个着色器并将着色器未使用的所有资源清零。这将完全从pass中删除这些资源，从而消除了通过图形跟踪它们的成本。</p>
<p>在清除任何资源之前，实用程序函数会自动为您调用 ValidateShaderParameters。这是通过确保在清除未使用的资源之前存在所有必需的资源来避免混淆。</p>
<h2 id="2-10-Repetitive-AddPass-Pattern重复的-AddPass-模式"><a href="#2-10-Repetitive-AddPass-Pattern重复的-AddPass-模式" class="headerlink" title="2.10 Repetitive AddPass Pattern重复的 AddPass 模式"></a>2.10 Repetitive AddPass Pattern重复的 AddPass 模式</h2><p><img src="Untitled47.png"></p>
<h2 id="2-11-Use-Helpers-as-Often-as-Possible-尽可能使用Helpers"><a href="#2-11-Use-Helpers-as-Often-as-Possible-尽可能使用Helpers" class="headerlink" title="2.11 Use Helpers as Often as Possible 尽可能使用Helpers"></a>2.11 Use Helpers as Often as Possible 尽可能使用Helpers</h2><p><img src="Untitled48.png"></p>
<p>对于常见情况，如计算着色器，实用函数可以删除大量样板文件。更少的样板意味着更少的复制粘贴错误和更容易的维护。</p>
<h2 id="2-12-GPU-Debugging-UAV-Trick-GPU调试UAV的技巧"><a href="#2-12-GPU-Debugging-UAV-Trick-GPU调试UAV的技巧" class="headerlink" title="2.12 GPU Debugging UAV Trick GPU调试UAV的技巧"></a>2.12 GPU Debugging UAV Trick GPU调试UAV的技巧</h2><p><img src="Untitled49.png"></p>
<p>顺便说一句，这里有一个巧妙的技巧：有时在调试着色器时，您只需要在纹理中进行良好的老式 printf 调试。这可以在 C++ 中设置一次，并在着色器代码中有条件地启用！</p>
<p>基本思想是创建一个可选的 RDG 纹理和关联的 UAV，然后将其绑定到您在整个功能开发过程中需要调试的每个Pass。然后，在着色器代码中，您可以有条件地声明纹理资源的存在并写入您想要的任何内容。当资源不活跃时，系统会自动剔除该资源。您可以使用可视化纹理工具查看自定义纹理的内容！</p>
<h2 id="2-13-Need-More-than-4-Channels-in-a-Texture-在一个纹理中需要-4-个以上的通道？"><a href="#2-13-Need-More-than-4-Channels-in-a-Texture-在一个纹理中需要-4-个以上的通道？" class="headerlink" title="2.13 Need More than 4 Channels in a Texture?在一个纹理中需要 4 个以上的通道？"></a>2.13 Need More than 4 Channels in a Texture?在一个纹理中需要 4 个以上的通道？</h2><p><img src="Untitled50.png"></p>
<blockquote>
<p>可能需要编码比像素格式可能提供的更多的信息。 （明显的例子：GBuffer）<br>需要读取和写入更多纹理。<br>需要设置所有这些纹理，就好像它们只是一个一样。<br>想抽象这些细节。</p>
</blockquote>
<p>作为另一个方法示例，考虑从多个纹理通道工作的Pass——超过任何单个纹理支持的最多四个通道。最好抽象一些此设置，以便实现将它们视为单个集合。</p>
<h2 id="2-14-Use-Structs-to-Group-Resources"><a href="#2-14-Use-Structs-to-Group-Resources" class="headerlink" title="2.14 Use Structs to Group Resources"></a>2.14 Use Structs to Group Resources</h2><p><img src="Untitled51.png"></p>
<p>为了实现这一点，我们可以将这些资源分组到着色器参数结构中并创建方法来初始化它们。这些函数的实现可以抽象出是否包含额外的纹理引用的细节。</p>
<h2 id="2-15-Resource-Structure-Setup-资源结构设置"><a href="#2-15-Resource-Structure-Setup-资源结构设置" class="headerlink" title="2.15 Resource Structure Setup 资源结构设置"></a>2.15 Resource Structure Setup 资源结构设置</h2><p><img src="Untitled52.png"></p>
<p>纹理结构的行为类似于本机 RDG 资源。设置代码中的复杂性被抽象为单独的函数，从而产生更加模块化的代码。</p>
<h2 id="2-16-Flexible-Structure-Nesting-灵活的结构嵌套"><a href="#2-16-Flexible-Structure-Nesting-灵活的结构嵌套" class="headerlink" title="2.16 Flexible Structure Nesting 灵活的结构嵌套"></a>2.16 Flexible Structure Nesting 灵活的结构嵌套</h2><p><img src="Untitled53.png"></p>
<p>着色器参数结构可以嵌套。在 C++ 中，这只是结构的组合。在着色器代码中，您必须使用结构名称作为结构成员的前缀，并用下划线分隔。在这个例子中，我们可以简单地引用结构，而不是手动列出所有输入纹理。</p>
<h2 id="2-17-Nesting-Common-Parameters-嵌套通用参数"><a href="#2-17-Nesting-Common-Parameters-嵌套通用参数" class="headerlink" title="2.17 Nesting Common Parameters 嵌套通用参数"></a>2.17 Nesting Common Parameters 嵌套通用参数</h2><p><img src="Untitled54.png"></p>
<p>没有关于资源结构的任何特定内容。任何着色器参数都可以嵌套。推荐的模式是识别多个Pass之间共享的常见着色器参数。这些参数可以提取到它们自己的结构体中，填充一次，然后再四处复制。使用单一代码路径来设置通用参数可降低维护成本。</p>
<h2 id="2-18-Include-Shader-Parameter-Struct"><a href="#2-18-Include-Shader-Parameter-Struct" class="headerlink" title="2.18 Include Shader Parameter Struct"></a>2.18 Include Shader Parameter Struct</h2><p><img src="Untitled55.png"></p>
<p>也可以在 C++ 端嵌套一个子结构，但将所有着色器名称吸收到父作用域中。在上面的示例中，构建了零碎的参数结构，然后将其组合到着色器的参数结构中。为了避免在着色器端创建多余的命名前缀，使用了 SHADER_PARAMETER_STRUCT_INCLUDE 变体。这会导致着色器名称扁平化到全局范围内，删除结构前缀。这在组织 C++ 中的更新频率时非常有用。例如，您可能有一系列引用相同的公共着色器参数的过程。通过包含通用参数，您可以在设置开始时构建它们，然后简单地复制它们。</p>
<h2 id="2-19-Setup-Nested-Structures-as-You-Please-根据需要设置嵌套结构"><a href="#2-19-Setup-Nested-Structures-as-You-Please-根据需要设置嵌套结构" class="headerlink" title="2.19 Setup Nested Structures as You Please 根据需要设置嵌套结构"></a>2.19 Setup Nested Structures as You Please 根据需要设置嵌套结构</h2><p><img src="Untitled56.png"></p>
<p>嵌套系统足够灵活，可以支持大多数需求。根据您的功能需求（例如代码重复、冗长等），使用您的判断来组织参数。虚幻引擎提供了实现这一目标所需的工具。</p>
<h2 id="2-20-Structure-Arrays-结构数组"><a href="#2-20-Structure-Arrays-结构数组" class="headerlink" title="2.20 Structure Arrays 结构数组"></a>2.20 Structure Arrays 结构数组</h2><p><img src="Untitled57.png"></p>
<p>我们之前介绍了使用 FDOFGatherInputTextures 将资源组织到结构中的便利性。事实证明，景深着色器之一需要为此资源结构的每个纹理生成一个 mip 链。系统支持 C++ 端的着色器参数结构数组，以帮助处理此用例。 C++ 使用直观的 for 循环设置每层的所有 UAV 变得更加方便。着色器代码不是最好的，原因与结构嵌套相同，但至少 C++ 端不受此限制。</p>
<h2 id="2-21-Event-Scopes"><a href="#2-21-Event-Scopes" class="headerlink" title="2.21 Event Scopes"></a>2.21 Event Scopes</h2><p><img src="Untitled58.png"></p>
<p>为了在 GPU 调试工具中更好地组织时序，可以在代码中添加事件范围以包含在其中创建的所有pass。<br>当与信息性能相关的信息结合时，事件会更有用。例如，景深可能必须支持 Alpha 通道。这会更改缓冲区布局并增加纹理提取。但是，将这些信息放在每次通过时可能会产生很多噪音。这是可以存储在整个范围内的信息。</p>
<h2 id="2-22-GPU-Timing-Aggregation"><a href="#2-22-GPU-Timing-Aggregation" class="headerlink" title="2.22 GPU Timing Aggregation"></a>2.22 GPU Timing Aggregation</h2><p><img src="Untitled59.png"></p>
<p>除了绘制事件之外，UE4 还跟踪存储桶中的 GPU 计时统计信息。这些通过 <code>stat gpu</code> 控制台命令显示。<br>GPU 统计支持仅以范围形式与 RDG 集成。每个Pass的 GPU 计时将在Pass设置时与最内部的范围聚合。</p>
<h1 id="Screen-Pass-Framework"><a href="#Screen-Pass-Framework" class="headerlink" title="Screen Pass Framework"></a>Screen Pass Framework</h1><h2 id="3-00-What-is-a-Screen-Pass？"><a href="#3-00-What-is-a-Screen-Pass？" class="headerlink" title="3.00 What is a Screen Pass？"></a>3.00 What is a Screen Pass？</h2><p><img src="Untitled60.png"></p>
<blockquote>
<p>只是一个读取纹理输入和写入纹理输出的Pass<br>大多数通过引擎；<br>帮助构建问题空间。<br>主要针对像素着色器；<br>该框架的组件也适用于计算。<br>选择了 Screen Pass 命名约定而不是后期处理；<br>更通用<br>SSS 是灯光合成的一部分——并不是真正的后期处理；</p>
</blockquote>
<p>首先，什么是screen pass？本质上，它只是一个读取纹理输入和写入纹理输出的Pass。该定义适用于引擎中的大多数pass，并有助于确定问题空间。虽然该框架主要针对像素着色器Pass，但某些组件也适用于compute pass。关于命名的注意事项：我们选择了“screen pass”约定而不是“post process”。我们觉得这更通用。例如，次表面散射在技术上不是后期处理，因为它在照明合成阶段运行。</p>
<h2 id="3-01-简化Pass创作"><a href="#3-01-简化Pass创作" class="headerlink" title="3.01 简化Pass创作"></a>3.01 简化Pass创作</h2><p><img src="Untitled61.png"></p>
<blockquote>
<p>Screen Pass要求；<br>描述输入/输出的着色器参数<br>    纹理范围、视口等。<br>大多数只需要一个像素/计算着色器<br>     隐藏区域网格？全屏三角？<br> 处理任意视口区域<br>     分屏/VR<br>     动态分辨率缩放<br>Screen pass框架为这些问题提供了解决方案</p>
</blockquote>
<p>有了前面的定义，让我们考虑一下screen pass的基本要求。</p>
<p>首先，着色器可能需要有关其纹理的信息；例如，以像素为单位的范围或 UV 坐标中的视口区域。</p>
<p>接下来，在大多数情况下，screen passes只需要一个像素或计算着色器。像素着色器的一个重要考虑因素是是否使用用于 VR 的 HMD 隐藏区域网格进行渲染，或者只是使用全屏三角形进行渲染。</p>
<p>最后，我们稍后会更深入地看到，我们需要灵活地渲染到输出纹理的视口或从输入纹理的视口渲染样本。这方面的用例包括分屏或 VR 和动态分辨率缩放。最终，screen pass框架的存在是为了解决这些问题。</p>
<h2 id="3-02-Texture-Viewports"><a href="#3-02-Texture-Viewports" class="headerlink" title="3.02 Texture Viewports"></a>3.02 Texture Viewports</h2><p><img src="Untitled62.png"></p>
<blockquote>
<p>对视口/范围对进行分组的简单类</p>
<ul>
<li> 用于派生着色器参数；</li>
<li> 用于为Screen Pass指定输入/输出视口；</li>
<li> 用于派生视口之间的 UV 变换。</li>
</ul>
</blockquote>
<p>screen pass 框架明确定义了一个纹理视口。这个数据结构描述了一个在纹理范围内定向的矩形——两者都以像素为单位。我们需要两者才能在 UV 坐标中表达视口并在视口之间映射。正如我们将在后续幻灯片中看到的，框架使用它来导出着色器参数、定义屏幕pass的输入和输出视口，以及在视口之间导出 UV 变换。</p>
<h2 id="3-03-Understanding-Texture-Viewports"><a href="#3-03-Understanding-Texture-Viewports" class="headerlink" title="3.03 Understanding Texture Viewports"></a>3.03 Understanding Texture Viewports</h2><p><img src="Untitled63.png"></p>
<blockquote>
<p>纹理视口区域可以从输入到输出不同。</p>
<ul>
<li>例如。解析后处理链以拆分屏幕视口（反之亦然）。</li>
</ul>
</blockquote>
<blockquote>
<p>想从着色器代码中抽象出来。</p>
<ul>
<li>主要是设置细节。着色器不在乎</li>
</ul>
</blockquote>
<p>要了解对纹理视口的需求，请考虑具有单个输入和输出纹理的Pass。一个重要的认识是这两个视口可以不同。分屏就是一个明显的例子。我们可能需要从分屏视口中读取，处理一些中间pass链，然后将结果合成回分屏视口。理想情况下，这些细节尽可能从着色器代码中抽象出来。</p>
<h2 id="3-04-Multiple-Input-Viewports"><a href="#3-04-Multiple-Input-Viewports" class="headerlink" title="3.04 Multiple Input Viewports"></a>3.04 Multiple Input Viewports</h2><p>![Untitled 64](RDG101/Untitled 64.png)</p>
<blockquote>
<p>纹理试图窗口可以区分不同的输入：</p>
<ul>
<li>比如：TAA 上采样之后的任何内容也需要深度/速度。<br>我们需要一种简单的方法来在视口之间映射 UV 坐标</li>
</ul>
</blockquote>
<p>在更高级的场景中，纹理视口甚至可能因输入而异。例如，在运动模糊中，深度和速度共享一个视口；然而，场景颜色已经从 TAA 上采样，所以它有第二个视口；最后，速度tile分类纹理有第三个。简而言之，我们需要一种简单的方法来映射这些视口空间之间的 UV 坐标。</p>
<h2 id="3-05-Texture-Viewport-Parameters"><a href="#3-05-Texture-Viewport-Parameters" class="headerlink" title="3.05 Texture Viewport Parameters"></a>3.05 Texture Viewport Parameters</h2><p><img src="Untitled65.png"></p>
<blockquote>
<p>描述着色器的纹理视口</p>
<ul>
<li>范围、视口、UV 视口等<br>不与纹理一对一绑定</li>
<li>可以共享（例如深度/速度）；</li>
<li>根据需要定义尽可能多或少的数量</li>
</ul>
</blockquote>
<p>为了解决着色器参数问题，框架定义了一个从纹理视口派生的新着色器参数结构。它提供纹理的范围和反范围等信息；像素或 UV 坐标中的视口矩形等。根据设计，它不与特定的纹理实例耦合，因为pass的多个输入往往共享相同的纹理视口。相反，您可以根据需要为您的pass定义任意数量。</p>
<h2 id="3-06-Texture-Viewport-Parameter-Setup"><a href="#3-06-Texture-Viewport-Parameter-Setup" class="headerlink" title="3.06 Texture Viewport Parameter Setup"></a>3.06 Texture Viewport Parameter Setup</h2><p><img src="Untitled66.png"></p>
<blockquote>
<p>pass属性结构的成员</p>
</blockquote>
<p>要使用纹理视口参数，只需将其添加为我们在前面幻灯片中看到的pass参数结构的成员。您可以直接从纹理视口实例化参数。</p>
<h2 id="3-07-Defining-in-the-shader"><a href="#3-07-Defining-in-the-shader" class="headerlink" title="3.07 Defining in the shader"></a>3.07 Defining in the shader</h2><p><img src="Untitled67.png"></p>
<blockquote>
<p>在HLSL中使用 SCREEN_PASS_TEXTURE_VIEWPORT 宏<br>在 ScreenPass.ush 中定义</p>
</blockquote>
<p>在着色器方面，框架提供了一个宏来定义 HLSL 中的纹理视口参数。这消除了添加每个单独成员的需要。它在 ScreenPass.ush 中定义。</p>
<h2 id="3-08-Draw-Screen-Pass-API"><a href="#3-08-Draw-Screen-Pass-API" class="headerlink" title="3.08 Draw Screen Pass API"></a>3.08 Draw Screen Pass API</h2><p><img src="Untitled68.png"></p>
<blockquote>
<p>用于像素着色器的过程</p>
<ul>
<li>抽象 HMD 网格与全屏三角形</li>
<li>抽象的shader设置<br>指定输入/输出纹理视口</li>
<li>自动 RHI 视口设置</li>
<li>自动 UV 坐标生成<br>存在其他低级变体：</li>
<li>比如：手动提交到命令列表</li>
</ul>
</blockquote>
<p>为了更轻松地使用像素着色器，该框架包含实用函数以将像素着色器pass直接添加到渲染图。它抽象了细节，比如是使用 HMD 网格还是全屏三角形。您提供输入和输出纹理视口，实现会自动处理 RHI 视口设置和 UV 坐标生成。如果您需要更多控制，则存在此功能的其他低级变体；例如，如果您需要手动设置您的pass并提交到命令列表。</p>
<h2 id="3-09-Transform-UV’s-Betweeen-Viewports"><a href="#3-09-Transform-UV’s-Betweeen-Viewports" class="headerlink" title="3.09 Transform UV’s Betweeen Viewports"></a>3.09 Transform UV’s Betweeen Viewports</h2><p><img src="Untitled69.png"></p>
<blockquote>
<p>将 UV 从一个视口映射到另一个视口的简单比例/偏置因子；</p>
<ul>
<li>Seen it used enough times to warrant making it a first class citizen.</li>
<li>无需继续派生（或复制粘贴）转换代码。</li>
<li>可以使用SCREEN_PASS_TEXTURE_VIEWPORT_TRANSFORM宏</li>
</ul>
</blockquote>
<p>最后，该框架提供了一种简单的变换类型来将 UV 坐标从一个视口空间映射到另一个视口空间。要实例化，只需传递您的源视口和目标视口。在着色器代码中，将比例/偏置因子应用于源 UV 坐标。在着色器中，您可以使用 SCREEN_PASS_TEXTURE_VIEWPORT_TRANSFORM 宏来快速定义变换。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%80%A7%E8%83%BD/" rel="tag"># 性能</a>
              <a href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag"># 渲染</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/12/18/Effect/" rel="next" title="Effect">
      Effect <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Shader-Parameters"><span class="nav-text">Shader Parameters</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Shader-Parameter-Structs"><span class="nav-text">Shader Parameter Structs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compile-Time-Reflection-Metadata"><span class="nav-text">Compile-Time Reflection Metadata</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-04-Automatic-Parameter-Alignment%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7%E5%AF%B9%E9%BD%90"><span class="nav-text">0.04 Automatic Parameter Alignment自动属性对齐</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-05-Sort-Members-to-Minimize-Padding%E5%AF%B9%E6%88%90%E5%91%98%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E4%BB%A5%E6%9C%80%E5%B0%8F%E5%8C%96%E5%A1%AB%E5%85%85"><span class="nav-text">0.05.Sort Members to Minimize Padding对成员进行排序以最小化填充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-06-Example-of-Tightly-Packed-Structure"><span class="nav-text">0.06:Example of Tightly Packed Structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-07-No-Need-to-Manually-Pack-Floats%E6%97%A0%E9%9C%80%E6%89%8B%E5%8A%A8%E6%89%93%E5%8C%85%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-text">0.07:No Need to Manually Pack Floats无需手动打包浮点数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-08-First-Shader-Class"><span class="nav-text">0.08.First Shader Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-09-Inlining-the-Struct-Definition%E5%86%85%E8%81%94%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-text">0.09:Inlining the Struct Definition内联结构定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-10-Assigning-Parameters%E5%A3%B0%E6%98%8E%E5%B1%9E%E6%80%A7"><span class="nav-text">0.10:Assigning Parameters声明属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-11%EF%BC%9ASubmitting-Parameters%E6%8F%90%E4%BA%A4%E5%B1%9E%E6%80%A7"><span class="nav-text">0.11：Submitting Parameters提交属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-12%EF%BC%9ADefining-a-Uniform-Buffer"><span class="nav-text">0.12：Defining a Uniform Buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-13-Uniform-Buffer-Code-Generation"><span class="nav-text">0.13:Uniform Buffer Code Generation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-14-Include-Uniform-Buffers-in-Shader-Parameter-Structs"><span class="nav-text">0.14 Include Uniform Buffers in Shader Parameter Structs</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Render-Graph-Basics"><span class="nav-text">Render Graph Basics</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-00-The-Render-Graph-Builder"><span class="nav-text">1.00 The Render Graph Builder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-01-Creating-a-Texture"><span class="nav-text">1.01 Creating a Texture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-02-Creating-a-UAV-for-a-Texture"><span class="nav-text">1.02 Creating a UAV for a Texture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-03-Creating-an-SRV-for-a-Texture"><span class="nav-text">1.03 Creating an SRV for a Texture</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-04-Pass-Parameters"><span class="nav-text">1.04 Pass Parameters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-05-Adding-a-Pass"><span class="nav-text">1.05 Adding a Pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-06-Profile-Events"><span class="nav-text">1.06 Profile Events</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-07-Pass-Parameter-Setup"><span class="nav-text">1.07 Pass Parameter Setup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-08-Pass-Execution-Lambda-Function"><span class="nav-text">1.08 Pass Execution Lambda Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-09-Render-Target-Bindings-Slots"><span class="nav-text">1.09 Render Target Bindings Slots</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-Binding-a-Color-Render-Target"><span class="nav-text">1.10 Binding a Color Render Target</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-Binding-Depth-Stencil-Target"><span class="nav-text">1.11 Binding Depth Stencil Target</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-Binding-UAVs-for-Pixel-Shaders"><span class="nav-text">1.12 Binding UAVs for Pixel Shaders</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-13-Registration"><span class="nav-text">1.13 Registration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-14-Extraction-Queries"><span class="nav-text">1.14 Extraction Queries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-15-Creating-Buffers"><span class="nav-text">1.15 Creating Buffers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-16-Reading-from-a-Buffer-Using-an-SRV"><span class="nav-text">1.16 Reading from a Buffer Using an SRV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-17-Indirect-Draw-Dispatch-Buffer"><span class="nav-text">1.17 Indirect Draw&#x2F;Dispatch Buffer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pass-Debugging-and-Methodology"><span class="nav-text">Pass Debugging and Methodology</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-00-VisualizeTexture-Integration"><span class="nav-text">2.00 VisualizeTexture Integration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-01-Selecting-a-Resource-Version"><span class="nav-text">2.01 Selecting a Resource Version</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-02-The-Downside-of-Deferred-Execution"><span class="nav-text">2.02 The Downside of Deferred Execution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-03-rdgimmediate"><span class="nav-text">2.03 -rdgimmediate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-04-rdgimmediate-in-action"><span class="nav-text">2.04 -rdgimmediate in action</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-05-Early-Validation-of-Shader-Parameters%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%82%E6%95%B0%E7%9A%84%E6%97%A9%E6%9C%9F%E9%AA%8C%E8%AF%81"><span class="nav-text">2.05 Early Validation of Shader Parameters着色器参数的早期验证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-06-rdgdebug"><span class="nav-text">2.06 -rdgdebug</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-07-Dependency-Methodology-White-Listing%E4%BE%9D%E8%B5%96%E6%96%B9%E6%B3%95%EF%BC%9A%E7%99%BD%E5%90%8D%E5%8D%95"><span class="nav-text">2.07 Dependency Methodology:White-Listing依赖方法：白名单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-08-Dependency-Methodology-Black-Listing%E4%BE%9D%E8%B5%96%E6%96%B9%E6%B3%95%EF%BC%9A%E9%BB%91%E5%90%8D%E5%8D%95"><span class="nav-text">2.08 Dependency Methodology : Black-Listing依赖方法：黑名单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-09-Automatic-Black-Listing-For-a-Single-Shader-Pass"><span class="nav-text">2.09 Automatic Black-Listing For a Single-Shader Pass</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-Repetitive-AddPass-Pattern%E9%87%8D%E5%A4%8D%E7%9A%84-AddPass-%E6%A8%A1%E5%BC%8F"><span class="nav-text">2.10 Repetitive AddPass Pattern重复的 AddPass 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-Use-Helpers-as-Often-as-Possible-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8Helpers"><span class="nav-text">2.11 Use Helpers as Often as Possible 尽可能使用Helpers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-12-GPU-Debugging-UAV-Trick-GPU%E8%B0%83%E8%AF%95UAV%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="nav-text">2.12 GPU Debugging UAV Trick GPU调试UAV的技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-13-Need-More-than-4-Channels-in-a-Texture-%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%BA%B9%E7%90%86%E4%B8%AD%E9%9C%80%E8%A6%81-4-%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E9%80%9A%E9%81%93%EF%BC%9F"><span class="nav-text">2.13 Need More than 4 Channels in a Texture?在一个纹理中需要 4 个以上的通道？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-14-Use-Structs-to-Group-Resources"><span class="nav-text">2.14 Use Structs to Group Resources</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-15-Resource-Structure-Setup-%E8%B5%84%E6%BA%90%E7%BB%93%E6%9E%84%E8%AE%BE%E7%BD%AE"><span class="nav-text">2.15 Resource Structure Setup 资源结构设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-16-Flexible-Structure-Nesting-%E7%81%B5%E6%B4%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%B5%8C%E5%A5%97"><span class="nav-text">2.16 Flexible Structure Nesting 灵活的结构嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-17-Nesting-Common-Parameters-%E5%B5%8C%E5%A5%97%E9%80%9A%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-text">2.17 Nesting Common Parameters 嵌套通用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-18-Include-Shader-Parameter-Struct"><span class="nav-text">2.18 Include Shader Parameter Struct</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-19-Setup-Nested-Structures-as-You-Please-%E6%A0%B9%E6%8D%AE%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84"><span class="nav-text">2.19 Setup Nested Structures as You Please 根据需要设置嵌套结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-20-Structure-Arrays-%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="nav-text">2.20 Structure Arrays 结构数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-21-Event-Scopes"><span class="nav-text">2.21 Event Scopes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-22-GPU-Timing-Aggregation"><span class="nav-text">2.22 GPU Timing Aggregation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Screen-Pass-Framework"><span class="nav-text">Screen Pass Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-00-What-is-a-Screen-Pass%EF%BC%9F"><span class="nav-text">3.00 What is a Screen Pass？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-01-%E7%AE%80%E5%8C%96Pass%E5%88%9B%E4%BD%9C"><span class="nav-text">3.01 简化Pass创作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-02-Texture-Viewports"><span class="nav-text">3.02 Texture Viewports</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-03-Understanding-Texture-Viewports"><span class="nav-text">3.03 Understanding Texture Viewports</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-04-Multiple-Input-Viewports"><span class="nav-text">3.04 Multiple Input Viewports</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-05-Texture-Viewport-Parameters"><span class="nav-text">3.05 Texture Viewport Parameters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-06-Texture-Viewport-Parameter-Setup"><span class="nav-text">3.06 Texture Viewport Parameter Setup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-07-Defining-in-the-shader"><span class="nav-text">3.07 Defining in the shader</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-08-Draw-Screen-Pass-API"><span class="nav-text">3.08 Draw Screen Pass API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-09-Transform-UV%E2%80%99s-Betweeen-Viewports"><span class="nav-text">3.09 Transform UV’s Betweeen Viewports</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NeoZheng"
      src="/images/MyShow.jpg">
  <p class="site-author-name" itemprop="name">NeoZheng</p>
  <div class="site-description" itemprop="description">潜心技术，努力奋斗</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aIFzzf" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aIFzzf" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/fzzf-90-50" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;fzzf-90-50" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2021-12 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NeoZheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">73k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:06</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'NMN4QIvjAh5qJ5q3mziedsgN-gzGzoHsz',
      appKey     : 'rIJIzKcDCj5iPy38T3RXtSa2',
      placeholder: "Comments welcome",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
