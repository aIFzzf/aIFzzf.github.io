<!DOCTYPE html>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="\js\FunnyTitle.js"></script>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon_study_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon_study_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文主要记录了UE5如何通过修改源代码添加扩充引擎GBuffer，同时对相关GBuffer进行细分学习过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Creating a new GBuffer in Unreal5">
<meta property="og:url" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/index.html">
<meta property="og:site_name" content="风中追风">
<meta property="og:description" content="本文主要记录了UE5如何通过修改源代码添加扩充引擎GBuffer，同时对相关GBuffer进行细分学习过程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%201.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%202.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%203.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%204.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%205.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%206.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%207.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%208.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%209.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2010.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2011.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2012.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2013.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2014.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2015.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2016.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2017.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2018.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2019.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2020.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2021.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2022.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2023.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2024.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2025.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2026.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2027.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2028.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2029.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2030.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2031.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2032.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2033.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2034.png">
<meta property="og:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled%2035.jpg">
<meta property="article:published_time" content="2022-09-19T14:36:00.000Z">
<meta property="article:modified_time" content="2023-06-01T16:26:40.860Z">
<meta property="article:author" content="NeoZheng">
<meta property="article:tag" content="UE">
<meta property="article:tag" content="Shading">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/Blog/source/_posts/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled.png">

<link rel="canonical" href="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Creating a new GBuffer in Unreal5 | 风中追风</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="风中追风" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">风中追风</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/MyShow.jpg">
      <meta itemprop="name" content="NeoZheng">
      <meta itemprop="description" content="潜心技术，努力奋斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风中追风">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Creating a new GBuffer in Unreal5
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-19 22:36:00" itemprop="dateCreated datePublished" datetime="2022-09-19T22:36:00+08:00">2022-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-02 00:26:40" itemprop="dateModified" datetime="2023-06-02T00:26:40+08:00">2023-06-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UnrealEngine/" itemprop="url" rel="index"><span itemprop="name">UnrealEngine</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/19/Creating%20a%20new%20GBuffer%20in%20Unreal5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>
            <div class="post-description">本文主要记录了UE5如何通过修改源代码添加扩充引擎GBuffer，同时对相关GBuffer进行细分学习过程。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Creating-a-new-GBuffer-in-Unreal5"><a href="#Creating-a-new-GBuffer-in-Unreal5" class="headerlink" title="Creating a new GBuffer in Unreal5"></a>Creating a new GBuffer in Unreal5</h1><p>新增一个GBuffer在UE来说较为复杂，主要需要修改以下文件，这里我先列举方便后期校对</p>
<ol>
<li>SceneTextures.h/.cpp ：负责声明创建SceneTexture及GBuffer相关Texture</li>
<li>GBufferInfo.h / .cpp ：负责声明GBuffer相关属性 </li>
<li>DeferredShadingCommon.ush  :  负责DecodeShaderingCommon</li>
<li>SceneTextureParameters.h/.cpp ：负责SceneTexture Parameter 绑定等</li>
<li>ShaderGenerationUtil.cpp ： 负责生成Shader</li>
<li>SceneTexturesCommon.ush ： SceneTextures 相关Common 函数</li>
<li>MaterialTemplate.ush ： hlsl函数模板</li>
<li>ShaderCompiler.h ： 负责Shader编译</li>
<li>PixelShaderOutputCommon ： PixelShaderOutput相关定义</li>
</ol>
<h1 id="1-什么是GBuffer？"><a href="#1-什么是GBuffer？" class="headerlink" title="1. 什么是GBuffer？"></a>1. 什么是GBuffer？</h1><p>延迟渲染管线不了解的话可以直接参考 0向往0 dalao的文章了解</p>
<p>The G-buffer is the collective term of all textures used to store lighting-relevant data for the final lighting pass. (定义来自<a target="_blank" rel="noopener" href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">here</a>)</p>
<p>了解了GBuffer的定义后我们来了解下UE对GBuffer的相关定义和处理：</p>
<h1 id="2-UE中的GBuffer解析"><a href="#2-UE中的GBuffer解析" class="headerlink" title="2.UE中的GBuffer解析"></a>2.UE中的GBuffer解析</h1><h2 id="2-1-初步了解GBuffer"><a href="#2-1-初步了解GBuffer" class="headerlink" title="2.1 初步了解GBuffer"></a>2.1 初步了解GBuffer</h2><p>首先我们在延迟渲染中可以通过Renderdoc 截取看到 在渲染流程中会在不同时期对 GBuffer 进行读取/写入。</p>
<p><img src="Blog/source/_posts/Creating%20a%20new%20GBuffer%20in%20Unreal5/Untitled.png"></p>
<p>UE会在渲染的BasePass阶段将场景相关信息写入存储到GBuffer中。并在后续Lighting阶段将GBuffer中的相关信息进行读取后参与计算光照结果。</p>
<p><img src="Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%201.png"></p>
<p><em>这里可以看到在直接光的计算中使用的相关Gbuffer的读取。</em></p>
<p>既然UE在基础的Deferred Rendering中使用到GBuffer，那我们先直接定位到 DeferredShadingRenderer.cpp 查看 Render 函数，这里由于本文篇幅原因不做详细解析，后续有时间笔者再补充下FDeferredShadingSceneRenderer::Render的相关细节流程，这里我直接使用总结的流程图：</p>
<p><img src="Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%202.png"></p>
<p>在渲染流程中，与GBuffer相关的处理主要是由FSceneTextures及其相关类进行处理。</p>
<p>主要是通过最开始根据 View 相关设置获得 SceneTexture 相关设置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> FSceneTexturesConfig SceneTexturesConfig = FSceneTexturesConfig::<span class="built_in">Create</span>(ViewFamily);</span><br><span class="line">	FSceneTexturesConfig::<span class="built_in">Set</span>(SceneTexturesConfig);</span><br></pre></td></tr></table></figure>

<p>之后通过FSceneTextures::Create 方法进行创建相关的 SceneTexture。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FSceneTextures&amp; SceneTextures = FSceneTextures::<span class="built_in">Create</span>(GraphBuilder, SceneTexturesConfig);</span><br></pre></td></tr></table></figure>

<p>并在相关BasePass Lighting 计算前后进行调用来将结果输出到GBuffer中。</p>
<p><img src="Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%203.png"></p>
<p>找到Render中对Gbuffer写入、读写位置后，继续深入FSceneTextures中进行研究。首先从Create函数开始，该函数主要是用于创建GBuffer对应的RT，在创建时会使用RDG的形式创建相应的2D Render Target</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SceneTextures.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Config.GBufferA.Index &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> FRDGTextureDesc <span class="title">Desc</span><span class="params">(FRDGTextureDesc::Create2D(Config.Extent, Config.GBufferA.Format, FClearValueBinding::Transparent, Config.GBufferA.Flags | FlagsToAdd | GFastVRamConfig.GBufferA))</span></span>;</span><br><span class="line">			SceneTextures.GBufferA = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;GBufferA&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Config.GBufferB.Index &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> FRDGTextureDesc <span class="title">Desc</span><span class="params">(FRDGTextureDesc::Create2D(Config.Extent, Config.GBufferB.Format, FClearValueBinding::Transparent, Config.GBufferB.Flags | FlagsToAdd | GFastVRamConfig.GBufferB))</span></span>;</span><br><span class="line">			SceneTextures.GBufferB = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;GBufferB&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Config.GBufferC.Index &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> FRDGTextureDesc <span class="title">Desc</span><span class="params">(FRDGTextureDesc::Create2D(Config.Extent, Config.GBufferC.Format, FClearValueBinding::Transparent, Config.GBufferC.Flags | FlagsToAdd | GFastVRamConfig.GBufferC))</span></span>;</span><br><span class="line">			SceneTextures.GBufferC = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;GBufferC&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Config.GBufferD.Index &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> FRDGTextureDesc <span class="title">Desc</span><span class="params">(FRDGTextureDesc::Create2D(Config.Extent, Config.GBufferD.Format, FClearValueBinding::Transparent, Config.GBufferD.Flags | FlagsToAdd | GFastVRamConfig.GBufferD))</span></span>;</span><br><span class="line">			SceneTextures.GBufferD = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;GBufferD&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (Config.GBufferE.Index &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> FRDGTextureDesc <span class="title">Desc</span><span class="params">(FRDGTextureDesc::Create2D(Config.Extent, Config.GBufferE.Format, FClearValueBinding::Transparent, Config.GBufferE.Flags | FlagsToAdd | GFastVRamConfig.GBufferE))</span></span>;</span><br><span class="line">			SceneTextures.GBufferE = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;GBufferE&quot;</span>));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>CreateSceneTextureUniformBuffer 函数会根据SetupMode进行初始化相应RT，其中最关键的就是通过EnumHasAnyFlags判断传入的SetupMode来进行RT的复制和修改</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">EnumHasAnyFlags</span>(SetupMode, ESceneTextureSetupMode::GBufferA) &amp;&amp; <span class="built_in">HasBeenProduced</span>(SceneTextures-&gt;GBufferA))</span><br><span class="line">&#123;</span><br><span class="line">		SceneTextureParameters.GBufferATexture = SceneTextures-&gt;GBufferA;</span><br><span class="line">				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在 SceneTextureParameters.h 中 定义了SceneTexture中相关RDG Texture的文件及相关方法，以辅助将GBuffer中的数据传递到相应的RT上进行绘制。</p>
<p>在 SceneTexturesCommon.ush 中定义了 RT 的采样器等来实现在GPU中进行读取。</p>
<p>至此我们基本了解UE在延迟渲染管线中对GBuffer对应RT的操作流程。</p>
<h2 id="2-2-UE如何定义GBuffer"><a href="#2-2-UE如何定义GBuffer" class="headerlink" title="2.2 UE如何定义GBuffer"></a>2.2 UE如何定义GBuffer</h2><p>UE中使用Encode和Decode机制来实现对GBuffer的写/读。并通过GBUFFER_REFACTOR宏来区别</p>
<p><img src="Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%204.png"></p>
<p><em>此处参考YivanLee大佬的文章</em></p>
<p>使用GBUFFER_REFACTOR宏来生成的是由C++部分生成 Encode 和 Decode 代码，负责生成代码的文件为 ShaderGenerationUtil.cpp ，可以在文件中查看</p>
<p><img src="Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%205.png"></p>
<p><em>（无力吐槽UE5使用FString拼接的方式实现C++控制HLSL的方法…debug起来十分不友好）</em></p>
<p>ShaderGenerationUtil 文件主要负责在C++层面写入HLSL的相关逻辑。这里会实现GBuffer 的 Decode（写入） 和 Encode（读取）方法。这些后续在添加自己的GBuffer的时候都是需要进行修改的。</p>
<p>另一种就是在ush中直接写好的。具体可查看 DeferredShadingCommon.ush ~</p>
<p><img src="Blog/source/_posts/Adding%20a%20new%20Shading%20Model/Untitled%206.png"></p>
<p>在FShaderCompileUtilities::ApplyDerivedDefines函数中把GBUFFER_REFACTOR宏加入实现区分。</p>
<p>在Decode Encode过程中，有一个结构特别关键：FGBufferData。</p>
<p>FGbufferData主要负责存储写入读出GBuffer的相关数据，在UE的PS阶段渲染函数BasePassPixelShader.usf 中看到调用 SetGBufferForShadingModel 来将相关 Material Input的数据传递给GBuffer。FGbufferData定义可以在DeferredShadingCommon.ush中查看。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all values that are output by the forward rendering pass</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FGBufferData</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// normalized</span></span><br><span class="line">	float3 WorldNormal;</span><br><span class="line">	<span class="comment">// normalized, only valid if HAS_ANISOTROPY_MASK in SelectiveOutputMask</span></span><br><span class="line">	float3 WorldTangent;</span><br><span class="line">	<span class="comment">// 0..1 (derived from BaseColor, Metalness, Specular)</span></span><br><span class="line">	float3 DiffuseColor;</span><br><span class="line">	<span class="comment">// 0..1 (derived from BaseColor, Metalness, Specular)</span></span><br><span class="line">	float3 SpecularColor;</span><br><span class="line">	<span class="comment">// 0..1, white for SHADINGMODELID_SUBSURFACE_PROFILE and SHADINGMODELID_EYE (apply BaseColor after scattering is more correct and less blurry)</span></span><br><span class="line">	float3 BaseColor;</span><br><span class="line">	<span class="comment">// 0..1</span></span><br><span class="line">	<span class="type">float</span> Metallic;</span><br><span class="line">	<span class="comment">// 0..1</span></span><br><span class="line">	<span class="type">float</span> Specular;</span><br><span class="line">	<span class="comment">// 0..1</span></span><br><span class="line">	float4 CustomData;</span><br><span class="line">	<span class="comment">// AO utility value</span></span><br><span class="line">	<span class="type">float</span> GenericAO;</span><br><span class="line">	<span class="comment">// Indirect irradiance luma</span></span><br><span class="line">	<span class="type">float</span> IndirectIrradiance;</span><br><span class="line">	<span class="comment">// Static shadow factors for channels assigned by Lightmass</span></span><br><span class="line">	<span class="comment">// Lights using static shadowing will pick up the appropriate channel in their deferred pass</span></span><br><span class="line">	float4 PrecomputedShadowFactors;</span><br><span class="line">	<span class="comment">// 0..1</span></span><br><span class="line">	<span class="type">float</span> Roughness;</span><br><span class="line">	<span class="comment">// -1..1, only valid if only valid if HAS_ANISOTROPY_MASK in SelectiveOutputMask</span></span><br><span class="line">	<span class="type">float</span> Anisotropy;</span><br><span class="line">	<span class="comment">// 0..1 ambient occlusion  e.g.SSAO, wet surface mask, skylight mask, ...</span></span><br><span class="line">	<span class="type">float</span> GBufferAO;</span><br><span class="line">	<span class="comment">// Bit mask for occlusion of the diffuse indirect samples</span></span><br><span class="line">	uint DiffuseIndirectSampleOcclusion;</span><br><span class="line">	<span class="comment">// 0..255 </span></span><br><span class="line">	uint ShadingModelID;</span><br><span class="line">	<span class="comment">// 0..255 </span></span><br><span class="line">	uint SelectiveOutputMask;</span><br><span class="line">	<span class="comment">// 0..1, 2 bits, use CastContactShadow(GBuffer) or HasDynamicIndirectShadowCasterRepresentation(GBuffer) to extract</span></span><br><span class="line">	<span class="type">float</span> PerObjectGBufferData;</span><br><span class="line">	<span class="comment">// in world units</span></span><br><span class="line">	<span class="type">float</span> CustomDepth;</span><br><span class="line">	<span class="comment">// Custom depth stencil value</span></span><br><span class="line">	uint CustomStencil;</span><br><span class="line">	<span class="comment">// in unreal units (linear), can be used to reconstruct world position,</span></span><br><span class="line">	<span class="comment">// only valid when decoding the GBuffer as the value gets reconstructed from the Z buffer</span></span><br><span class="line">	<span class="type">float</span> Depth;</span><br><span class="line">	<span class="comment">// Velocity for motion blur (only used when WRITES_VELOCITY_TO_GBUFFER is enabled)</span></span><br><span class="line">	float4 Velocity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// My Custom Depth </span></span><br><span class="line">	float4 MyCustomDepth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0..1, only needed by SHADINGMODELID_SUBSURFACE_PROFILE and SHADINGMODELID_EYE which apply BaseColor later</span></span><br><span class="line">	float3 StoredBaseColor;</span><br><span class="line">	<span class="comment">// 0..1, only needed by SHADINGMODELID_SUBSURFACE_PROFILE and SHADINGMODELID_EYE which apply Specular later</span></span><br><span class="line">	<span class="type">float</span> StoredSpecular;</span><br><span class="line">	<span class="comment">// 0..1, only needed by SHADINGMODELID_EYE which encodes Iris Distance inside Metallic</span></span><br><span class="line">	<span class="type">float</span> StoredMetallic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处只是定义好Gbuffer的Encode及Decode的方式，于是笔者继续深入，找到UE对GBuffer在C++侧定义的位置（GBufferInfo.h/.cpp），该文件定义了Gbuffer相关属性：</p>
<ul>
<li>EGBufferSlot：GBuffer相关内容接口</li>
<li>EGBufferCompression：GBuffer相关压缩格式</li>
<li>EGBufferType：GBuffer输出到Texture时Texture的格式</li>
<li>FGBufferItem：在GBuffer中Texture的位置</li>
<li>FGBufferBinding：GBuffer相关绑定信息，负责绑定GBuffer相关Format及CreateFlags</li>
</ul>
<p>同时也定义了Gbuffer相关函数：</p>
<ul>
<li>FindGBufferTargetByName：通过name来查询对应的Gbuffer的RenderTarget</li>
<li>FindGBufferBindingByName：通过name来找到GBuffer绑定的信息，内部会调用FindGBufferTargetByName</li>
<li>FetchFullGBufferInfo/FetchLegacyGBufferInfo：负责绑定GBuffer的相关信息，这个函数会设置FGBufferInfo所有信息，包括初始化GBuffer的格式及各个通道的数据类型绑定情况</li>
<li>FetchGBufferSlots：负责设置GBufferSlots，该步骤会在将需要写入GBuffer的EGBufferSlot存放成一个TArray，方便后续绑定使用。</li>
</ul>
<p>至此GBuffer的相关定义也已完成，接下来笔者继续研究了UE中GBuffer中的组成部分。</p>
<h2 id="2-3-UE-中-GBuffer-的组成"><a href="#2-3-UE-中-GBuffer-的组成" class="headerlink" title="2.3 UE 中 GBuffer 的组成"></a>2.3 UE 中 GBuffer 的组成</h2><p>从前面的解析，可以了解到GBuffer的读取主要是通过Decode来进行，所以我们直接定位到延迟渲染中的EncodeGBuffer函数。该函数主要用于将 FGBufferData 中的相关数据解析后输出给 各个buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeferredShadingCommon.ush</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Populates OutGBufferA, B and C */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EncodeGBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	FGBufferData GBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float4 OutGBufferA,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float4 OutGBufferB,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float4 OutGBufferC,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float4 OutGBufferD,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float4 OutGBufferE,</span></span></span><br><span class="line"><span class="params"><span class="function">	out float4 OutGBufferVelocity,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">/*out float4 OutMyCustomDepth,*/</span> <span class="comment">//注释的是我自己加入的GBuffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">float</span> QuantizationBias = <span class="number">0</span>		<span class="comment">// -0.5 to 0.5 random float. Used to bias quantization.</span></span></span></span><br><span class="line"><span class="params"><span class="function">	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (GBuffer.ShadingModelID == SHADINGMODELID_UNLIT)</span><br><span class="line">	&#123;</span><br><span class="line">		OutGBufferA = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">SetGBufferForUnlit</span>(OutGBufferB);</span><br><span class="line">		OutGBufferC = <span class="number">0</span>;</span><br><span class="line">		OutGBufferD = <span class="number">0</span>;</span><br><span class="line">		OutGBufferE = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MOBILE_DEFERRED_SHADING</span></span><br><span class="line">		OutGBufferA.rg = <span class="built_in">UnitVectorToOctahedron</span>( <span class="built_in">normalize</span>(GBuffer.WorldNormal) ) * <span class="number">0.5f</span> + <span class="number">0.5f</span>;</span><br><span class="line">		OutGBufferA.b = GBuffer.PrecomputedShadowFactors.x;</span><br><span class="line">		OutGBufferA.a = GBuffer.PerObjectGBufferData;		</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 1</span></span><br><span class="line">		OutGBufferA.rgb = <span class="built_in">EncodeNormal</span>( GBuffer.WorldNormal );</span><br><span class="line">		OutGBufferA.a = GBuffer.PerObjectGBufferData;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		float3 Normal = GBuffer.WorldNormal;</span><br><span class="line">		uint   NormalFace = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">EncodeNormal</span>( Normal, NormalFace );</span><br><span class="line"></span><br><span class="line">		OutGBufferA.rg = Normal.xy;</span><br><span class="line">		OutGBufferA.b = <span class="number">0</span>;</span><br><span class="line">		OutGBufferA.a = GBuffer.PerObjectGBufferData;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		OutGBufferB.r = GBuffer.Metallic;</span><br><span class="line">		OutGBufferB.g = GBuffer.Specular;</span><br><span class="line">		OutGBufferB.b = GBuffer.Roughness;</span><br><span class="line">		OutGBufferB.a = <span class="built_in">EncodeShadingModelIdAndSelectiveOutputMask</span>(GBuffer.ShadingModelID, GBuffer.SelectiveOutputMask);</span><br><span class="line"></span><br><span class="line">		OutGBufferC.rgb = <span class="built_in">EncodeBaseColor</span>( GBuffer.BaseColor );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION</span></span><br><span class="line">		OutGBufferC.a = <span class="built_in">float</span>(GBuffer.DiffuseIndirectSampleOcclusion) * <span class="built_in">rcp</span>(<span class="number">255</span>) + (<span class="number">0.5</span> / <span class="number">255.0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> ALLOW_STATIC_LIGHTING</span></span><br><span class="line">		<span class="comment">// No space for AO. Multiply IndirectIrradiance by AO instead of storing.</span></span><br><span class="line">		OutGBufferC.a = <span class="built_in">EncodeIndirectIrradiance</span>(GBuffer.IndirectIrradiance * GBuffer.GBufferAO) + QuantizationBias * (<span class="number">1.0</span> / <span class="number">255.0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		OutGBufferC.a = GBuffer.GBufferAO;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		OutGBufferD = GBuffer.CustomData;</span><br><span class="line">		OutGBufferE = GBuffer.PrecomputedShadowFactors;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WRITES_VELOCITY_TO_GBUFFER</span></span><br><span class="line">	GBufferF= GBuffer.Velocity;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	OutGBufferVelocity = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*OutMyCustomDepth = GBuffer.MyCustomDepth;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会在FPixelShaderInOut_MainPS中进行最后调用，将FGbufferData中的数据输出到GBuffer中。</p>
<p>通过分析可以看到UE5中对GBuffer做了一下分配：</p>
<ul>
<li>手机端延迟渲染管线</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>G</th>
<th>B</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>GBufferA</td>
<td>Normal</td>
<td>Normal</td>
<td>PrecomputedShadowFactors.x</td>
<td>PerObjectGBufferData</td>
</tr>
<tr>
<td>GBufferB</td>
<td>Metallic</td>
<td>Specular</td>
<td>Roughness</td>
<td>ShadingModelID+SelectiveOutputMask(各占4bit，Shading Mode最大值16）</td>
</tr>
<tr>
<td>GBufferC</td>
<td>BaseColor</td>
<td>BaseColor</td>
<td>BaseColor</td>
<td>见注释</td>
</tr>
<tr>
<td>GBufferD</td>
<td>CustomData</td>
<td>CustomData</td>
<td>CustomData</td>
<td>CustomData</td>
</tr>
<tr>
<td>OutGBufferE</td>
<td>PrecomputedShadowFactors</td>
<td>PrecomputedShadowFactors</td>
<td>PrecomputedShadowFactors</td>
<td>PrecomputedShadowFactors</td>
</tr>
<tr>
<td>GBufferF</td>
<td>Velocity</td>
<td>Velocity</td>
<td>Velocity</td>
<td>各向异性强度</td>
</tr>
</tbody></table>
<ul>
<li>延迟渲染管线</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>G</th>
<th>B</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>GBufferA</td>
<td>Normal</td>
<td>Normal</td>
<td>Normal</td>
<td>PerObjectGBufferData</td>
</tr>
<tr>
<td>GBufferB</td>
<td>Metallic</td>
<td>Specular</td>
<td>Roughness</td>
<td>ShadingModelID+SelectiveOutputMask(各占4bit，Shading Mode最大值16）</td>
</tr>
<tr>
<td>GBufferC</td>
<td>BaseColor</td>
<td>BaseColor</td>
<td>BaseColor</td>
<td>见注释</td>
</tr>
<tr>
<td>GBufferD</td>
<td>CustomData</td>
<td>CustomData</td>
<td>CustomData</td>
<td>CustomData</td>
</tr>
<tr>
<td>OutGBufferE</td>
<td>PrecomputedShadowFactors</td>
<td>PrecomputedShadowFactors</td>
<td>PrecomputedShadowFactors</td>
<td>PrecomputedShadowFactors</td>
</tr>
<tr>
<td>GBufferF</td>
<td>Velocity</td>
<td>Velocity</td>
<td>Velocity</td>
<td>各向异性强度</td>
</tr>
</tbody></table>
<ul>
<li>在GBufferA禁用的分支里可以Encode法线到RG，如果这样做了B可以空出一个10bit，但移动没法使用。</li>
<li>GBufferC的Alpha通道在有静态光照时候储存随机抖动过的IndirectIrradiance*Material AO，否则直接储存Material AO。</li>
</ul>
<h2 id="2-4-UE中GBuffer光照相关计算"><a href="#2-4-UE中GBuffer光照相关计算" class="headerlink" title="2.4 UE中GBuffer光照相关计算"></a>2.4 UE中GBuffer光照相关计算</h2><h3 id="2-4-1-延迟渲染管线"><a href="#2-4-1-延迟渲染管线" class="headerlink" title="2.4.1 延迟渲染管线"></a>2.4.1 延迟渲染管线</h3><p>在延迟管线BasePass 的 GBuffer 数据填充后，会在 DiffuseIndirectAndAO 阶段中将间接光计算的漫反射 和 镜面反射 叠加到 GBuffer 中的BaseColor部分。（Note：不同方案会进行不同处理）</p>
<p>DiffuseIndirectAndAO 中包含了Lumen 相关 Radiosity 计算（感兴趣的朋友可以阅读 丛越dalao 文章），在完成间接光照计算后，GBuffer中的 BaseColor 将GI 计算结果 和 AO 叠加到 GBuffer 的 BaseColor 的过程叫 DiffuseIndirectComposite 。</p>
<p>DiffuseIndirectComposite 会将前面生成的DiffuseIndirect、RoughSpecularIndirect、SpecularIndirect 等与场景GBuffer 组合生成最终场景颜色 （同时包括bentNormal）。具体实现代码可以在IndirectLightRendering.cpp 中查看。组合过程可以在DiffuseIndirectComposite.usf中查看。</p>
<p>首先我们可以看下IndirectLightRendering.cpp 中，在该文件中会通过DIM_APPLY_DIFFUSE_INDIRECT宏来区分不同间接光方案。不同间接光方案在后续计算间接光对BaseColor的方式会有所不同。</p>
<p><img src="Untitled%207.png"></p>
<p>后续在DiffuseIndirectComposite.usf 中 </p>
<p><strong>在Lumen的间接光环境下，UE默认材质不会计算间接光的高光遮蔽计算（BentNormal除外） ，只会将漫反射间接光的遮蔽信息相乘到BaseColor上。</strong></p>
<p><img src="Untitled%208.png"></p>
<p>其他间接光模式后续再做进一步补充。</p>
<p>在后处理中 SSGI 也会调用到 GBuffer 进行渲染。主要是对AO进行相关处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DiffuseIndirectComposite.usf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DIM_APPLY_DIFFUSE_INDIRECT</span></span><br><span class="line">    &#123;</span><br><span class="line">        float3 DiffuseColor = GBuffer.DiffuseColor;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UseSubsurfaceProfile</span>(GBuffer.ShadingModelID))</span><br><span class="line">        &#123;</span><br><span class="line">            DiffuseColor = GBuffer.StoredBaseColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutColor.rgb += DiffuseColor * DiffuseIndirectTexture.<span class="built_in">SampleLevel</span>(DiffuseIndirectSampler, BufferUV, <span class="number">0</span>).rgb;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用AO到场景颜色. 因为在延迟直接照明之前，假设SceneColor中的所有照明都是间接照明.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> AOMask = (GBuffer.ShadingModelID != SHADINGMODELID_UNLIT);</span><br><span class="line">        OutColor.a = <span class="built_in">lerp</span>(<span class="number">1.0f</span>, FinalAmbientOcclusion, AOMask * AmbientOcclusionStaticFraction);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-移动延迟渲染管线"><a href="#2-4-2-移动延迟渲染管线" class="headerlink" title="2.4.2 移动延迟渲染管线"></a>2.4.2 移动延迟渲染管线</h3><p>开启方法 ： Mobile默认还是会使用forward shading。也可以手动设置，使得mobile使用pc renderer（“平台”-&gt;”项目设置”。默认为deferred，也可以使用forward）。但总的来说在mobile使用pc renderer不合适。</p>
<p>所以，引入了新的针对mobile GPU优化过的deferred shading。启用它的方法是在DefaultEngine.ini中添加r.Mobile.ShadingPath=1。</p>
<p>Mobile Deferred Shading 通过断点可一查看到在 MobileShadingRenderer.cpp 中 调用。</p>
<p><strong>在移动延迟渲染管线MobileBasePass的GBuffer数据填充后，不存在DiffuseIndirectAndAO的叠加过程，而是通过与间接光编码存在GBufferC.a 中 ，后续用于Diffuse IBL 的遮蔽计算，Specular没有进行遮蔽计算。</strong></p>
<p><img src="Untitled%209.png"></p>
<p>在MobileDeferredShading.usf 中设置读取GBufferAO进行叠加</p>
<p><img src="Untitled%2010.png"></p>
<p><img src="Untitled%2011.png"></p>
<h1 id="3-实践：如何在UE5中添加自己的GBuffer"><a href="#3-实践：如何在UE5中添加自己的GBuffer" class="headerlink" title="3. 实践：如何在UE5中添加自己的GBuffer"></a>3. 实践：如何在UE5中添加自己的GBuffer</h1><p>介绍完GBuffer相关细节后，笔者开始尝试添加自己的GBuffer，这里感谢下 yivanlee dalao文章做的指导orz~</p>
<p>本人将基于上一篇文章的思路进行修改~</p>
<h2 id="3-1-声明GBuffer-Slot"><a href="#3-1-声明GBuffer-Slot" class="headerlink" title="3.1 声明GBuffer Slot"></a>3.1 声明GBuffer Slot</h2><p>GBufferInfo 用于声明设置 GBuffer 相关信息，包括GBuffer的名字、格式、相关可读性</p>
<p>首先我们需要在GBufferInfo文件中声明相关GBuffer声明。</p>
<p>在EGBufferSlot中添加写入GBuffer的类型，在FetchGBufferSlots函数中的EGBufferSlot数组中添加对应类型</p>
<p><img src="Untitled%2012.png"></p>
<p>并在 FetchLegacyGBufferInfo 函数中新增新GBuffer的Target及在Slot的绑定信息</p>
<p><img src="Untitled%2013.png"></p>
<p>Note需要在NumTargets中新增1（因为增加了自己的Buffer）</p>
<p><img src="Untitled%2014.png"></p>
<p><img src="Untitled%2015.png"></p>
<p><img src="Untitled%2016.png"></p>
<p>进入到 GBufferInfo.h 的头文件中，修改FGBufferInfo的MaxTargets</p>
<p><img src="Untitled%2017.png"></p>
<h2 id="3-2-添加FGBufferData"><a href="#3-2-添加FGBufferData" class="headerlink" title="3.2 添加FGBufferData"></a>3.2 添加FGBufferData</h2><p>找到 DeferredShadingCommon.ush ，并在 struct FGBufferData 中添加新的数据格式</p>
<p><img src="Untitled%2018.png"></p>
<h2 id="3-3-创建对应RT并绑定"><a href="#3-3-创建对应RT并绑定" class="headerlink" title="3.3 创建对应RT并绑定"></a>3.3 创建对应RT并绑定</h2><p>首先定位到SceneTextures.h文件，并在FSceneTexturesConfig结构定义FGBufferBinding 的地方添加自己的 GBuffer Binding</p>
<p><img src="Untitled%2019.png"></p>
<p>同时在FSceneTextures结构中添加相应RT的RDGTextureRef</p>
<p><img src="Untitled%2020.png"></p>
<p>接下来来到 SceneTextures.cpp 中，在FSceneTexturesConfig::Create函数中将Config中的Buffer与名字进行绑定：</p>
<p><img src="Untitled%2021.png"></p>
<p>然后在FSceneTextures::Create函数中添加逻辑判断Config是否使用到相应GBuffer，并创建相应的RT，Note：这里可以设置RT的相关格式~</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Config.MyCustomDepth.Index &gt;= <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function"><span class="type">const</span> FRDGTextureDesc <span class="title">Desc</span><span class="params">(FRDGTextureDesc::Create2D(Config.Extent, Config.MyCustomDepth.Format, FClearValueBinding(&#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;), Config.MyCustomDepth.Flags | FlagsToAdd | GFastVRamConfig.MyCustomDepth))</span></span>;</span><br><span class="line">			SceneTextures.MyCustomDepthTexture = GraphBuilder.<span class="built_in">CreateTexture</span>(Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;MyCustomDepth&quot;</span>));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>同时在FSceneTextures::GetGBufferRenderTargets函数中添加相关GBuffer</p>
<p><img src="Untitled%2022.png"></p>
<p>同时在同文件中的SetupSceneTextureUniformParameters函数中修改将RT与GBuffer进行绑定。这里需要调用EnumHasAnyFlags函数进行判断是否需要进行复制。</p>
<p><img src="Untitled%2023.png"></p>
<p>（同理移动端在下方的SetupMobileSceneTextureUniformParameters函数也可进行设置，由于笔者实现的PC的逻辑，移动端可自行拓展）</p>
<h2 id="3-4-Encode-And-Decode"><a href="#3-4-Encode-And-Decode" class="headerlink" title="3.4 Encode And Decode"></a>3.4 Encode And Decode</h2><p>接下来修改GBuffer的Encode和Decode机制，打开ShaderGenerationUtil.cpp，首页需要在GetSlotTextName函数中创建对应的接口名称：</p>
<p><img src="Untitled%2024.png"></p>
<p>然后在 SetSharedGBufferSlots 函数中将对应的Slots解析接口打开（这里打开的话是默认全部打开，也可以在SetSlotsForShadingModelType 中对单独材质类型进行打开）</p>
<p><img src="Untitled%2025.png"></p>
<p>然后在 SetStandardGBufferSlots 中 将对应接口在不同条件下判断是否开启进行添加。</p>
<p><img src="Untitled%2026.png"></p>
<p>该函数主要会用在DetermineUsedMaterialSlots函数，DetermineUsedMaterialSlots会设置不同shadingmodel所需要的GBuffer情况及是否使用相关CustomData。不了解ShadingModel的朋友可以查看我上一篇文章。这里我们需要为我们上一篇自定义的Shadingmodel添加相关GBuffer设置</p>
<p><img src="Untitled%2027.png"></p>
<h2 id="3-5-写入GBuffer"><a href="#3-5-写入GBuffer" class="headerlink" title="3.5 写入GBuffer"></a>3.5 写入GBuffer</h2><p>写入GBuffer部分需要到Shader中进行设置。首先我们打开 DeferredShadingCommon.ush ，并在相应的encode区域添加 新增 GBuffer的绑定。</p>
<p>Note：需要通过#ifndef MOBILE_DEFERRED_SHADING 的方式来绕开 MOBILE_DEFERRED_SHADING</p>
<p><img src="Untitled%2028.png"></p>
<p>然后在默认的Decode函数中添加相关Decode</p>
<p><img src="Untitled%2029.png"></p>
<p>GetGBufferDataUint 函数中添加采样</p>
<p><img src="Untitled%2030.png"></p>
<p>GetGBufferDataFromSceneTextures 函数中添加采样</p>
<p><img src="Untitled%2031.png"></p>
<p>GetGBufferData 函数中添加采样</p>
<p><img src="Untitled%2032.png"></p>
<p>接下来打开 BasePassPixelShader.usf ，在FPixelShaderInOut_MainPS中添加HLSL中默认的绑定。</p>
<p><img src="Untitled%2033.png"></p>
<p>最后在ShaderGenerationUtil.cpp 文件的 SetSlotsForShadingModelType中添加默认GBufferSlots（Note：可见3.4节笔者的注释） </p>
<p><img src="Untitled%2034.png"></p>
<h2 id="3-3-调试GBuffer"><a href="#3-3-调试GBuffer" class="headerlink" title="3.3 调试GBuffer"></a>3.3 调试GBuffer</h2><p>编译后进行调试，通过打断点检查OutputData的方式查看相关Encode及Decode函数的正确性</p>
<p>最后结果为：</p>
<p><img src="Untitled%2035.jpg"></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>在UE中新增GBuffer的步骤有些过于复杂，同时UE使用C++控制HLSL的过程在Debug过程中比较有难度。同时新增的GBuffer也会增加相关带宽消耗（移动端几乎可以放弃）。</p>
<p>不过新增GBuffer可以将BasePass阶段相关数据存储为RT后传递给后续流程进行计算。写下这边笔记记录下过程，希望对大家有帮助~</p>
<h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/562673914"></a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/521681785">虚幻五渲染编程（Graphic篇）【第六卷： Customize GBuffer of UnrealEngine5】</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/15092257.html">https://www.cnblogs.com/timlly/p/15092257.html</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/UE/" rel="tag"># UE</a>
              <a href="/tags/Shading/" rel="tag"># Shading</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/14/Adding%20a%20new%20Shading%20Model/" rel="prev" title="Adding a new Shading Model in Unreal5">
      <i class="fa fa-chevron-left"></i> Adding a new Shading Model in Unreal5
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/01/Modify%20Render%20Pipeline%20By%20Plugin%20in%20UE5/" rel="next" title="使用插件修改UE5渲染管线">
      使用插件修改UE5渲染管线 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Creating-a-new-GBuffer-in-Unreal5"><span class="nav-text">Creating a new GBuffer in Unreal5</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFGBuffer%EF%BC%9F"><span class="nav-text">1. 什么是GBuffer？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-UE%E4%B8%AD%E7%9A%84GBuffer%E8%A7%A3%E6%9E%90"><span class="nav-text">2.UE中的GBuffer解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3GBuffer"><span class="nav-text">2.1 初步了解GBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-UE%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89GBuffer"><span class="nav-text">2.2 UE如何定义GBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-UE-%E4%B8%AD-GBuffer-%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">2.3 UE 中 GBuffer 的组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-UE%E4%B8%ADGBuffer%E5%85%89%E7%85%A7%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97"><span class="nav-text">2.4 UE中GBuffer光照相关计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="nav-text">2.4.1 延迟渲染管线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E7%A7%BB%E5%8A%A8%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF"><span class="nav-text">2.4.2 移动延迟渲染管线</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%AE%9E%E8%B7%B5%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8UE5%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E7%9A%84GBuffer"><span class="nav-text">3. 实践：如何在UE5中添加自己的GBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E5%A3%B0%E6%98%8EGBuffer-Slot"><span class="nav-text">3.1 声明GBuffer Slot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E6%B7%BB%E5%8A%A0FGBufferData"><span class="nav-text">3.2 添加FGBufferData</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94RT%E5%B9%B6%E7%BB%91%E5%AE%9A"><span class="nav-text">3.3 创建对应RT并绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Encode-And-Decode"><span class="nav-text">3.4 Encode And Decode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E5%86%99%E5%85%A5GBuffer"><span class="nav-text">3.5 写入GBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E8%B0%83%E8%AF%95GBuffer"><span class="nav-text">3.3 调试GBuffer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-text">4. 总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%8F%82%E8%80%83"><span class="nav-text">5. 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="NeoZheng"
      src="/images/MyShow.jpg">
  <p class="site-author-name" itemprop="name">NeoZheng</p>
  <div class="site-description" itemprop="description">潜心技术，努力奋斗</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aIFzzf" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aIFzzf" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/fzzf-90-50" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;fzzf-90-50" rel="noopener" target="_blank"><i class="fab fa-zhihu fa-fw"></i>Zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2021-12 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NeoZheng</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">80k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:13</span>
</div>



<a target="_blank" rel="noopener" href="https://clustrmaps.com/site/1bvog"  title="Visit tracker"><img src="//www.clustrmaps.com/map_v2.png?d=ef1vlhpw_-0wsQu24U9IbSB1cwBDxot163_KRfgVoGY&cl=ffffff" /></a>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'NMN4QIvjAh5qJ5q3mziedsgN-gzGzoHsz',
      appKey     : 'rIJIzKcDCj5iPy38T3RXtSa2',
      placeholder: "Comments welcome",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
